"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/algorand.ts":
/*!*******************************!*\
  !*** ./src/utils/algorand.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALGOD_PORT: function() { return /* binding */ ALGOD_PORT; },\n/* harmony export */   ALGOD_SERVER: function() { return /* binding */ ALGOD_SERVER; },\n/* harmony export */   ALGOD_TOKEN: function() { return /* binding */ ALGOD_TOKEN; },\n/* harmony export */   APP_ID: function() { return /* binding */ APP_ID; },\n/* harmony export */   buildCreateProjectTxn: function() { return /* binding */ buildCreateProjectTxn; },\n/* harmony export */   claimRefund: function() { return /* binding */ claimRefund; },\n/* harmony export */   contributeToProject: function() { return /* binding */ contributeToProject; },\n/* harmony export */   createProject: function() { return /* binding */ createProject; },\n/* harmony export */   formatAlgoAmount: function() { return /* binding */ formatAlgoAmount; },\n/* harmony export */   formatTimestamp: function() { return /* binding */ formatTimestamp; },\n/* harmony export */   getAlgodClient: function() { return /* binding */ getAlgodClient; },\n/* harmony export */   getProgressPercentage: function() { return /* binding */ getProgressPercentage; },\n/* harmony export */   getProjects: function() { return /* binding */ getProjects; },\n/* harmony export */   getTimeRemaining: function() { return /* binding */ getTimeRemaining; },\n/* harmony export */   mintRewardNFT: function() { return /* binding */ mintRewardNFT; },\n/* harmony export */   optInToApp: function() { return /* binding */ optInToApp; },\n/* harmony export */   parseAlgoAmount: function() { return /* binding */ parseAlgoAmount; },\n/* harmony export */   submitSignedTransaction: function() { return /* binding */ submitSignedTransaction; },\n/* harmony export */   waitForConfirmation: function() { return /* binding */ waitForConfirmation; },\n/* harmony export */   withdrawFunds: function() { return /* binding */ withdrawFunds; }\n/* harmony export */ });\n/* harmony import */ var algosdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! algosdk */ \"(app-pages-browser)/./node_modules/algosdk/dist/esm/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n// Algorand Testnet configuration\nconst ALGOD_TOKEN = \"\";\nconst ALGOD_SERVER = \"https://testnet-api.algonode.cloud\";\nconst ALGOD_PORT = 443;\n// Application configuration\nconst APP_ID = 746106150 // Latest deployed smart contract ID\n;\nconst getAlgodClient = ()=>{\n    return new algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Algodv2(ALGOD_TOKEN, ALGOD_SERVER, ALGOD_PORT);\n};\nconst formatAlgoAmount = (microAlgos)=>{\n    return (microAlgos / 1000000).toFixed(2);\n};\nconst parseAlgoAmount = (algos)=>{\n    return Math.floor(parseFloat(algos) * 1000000);\n};\nconst formatTimestamp = (timestamp)=>{\n    return new Date(timestamp * 1000).toLocaleDateString();\n};\nconst getTimeRemaining = (deadline)=>{\n    const now = Math.floor(Date.now() / 1000);\n    const remaining = deadline - now;\n    if (remaining <= 0) {\n        return \"Expired\";\n    }\n    const days = Math.floor(remaining / 86400);\n    const hours = Math.floor(remaining % 86400 / 3600);\n    const minutes = Math.floor(remaining % 3600 / 60);\n    if (days > 0) {\n        return \"\".concat(days, \"d \").concat(hours, \"h \").concat(minutes, \"m\");\n    } else if (hours > 0) {\n        return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n    } else {\n        return \"\".concat(minutes, \"m\");\n    }\n};\nconst getProgressPercentage = (collected, target)=>{\n    if (target === 0) return 0;\n    return Math.min(collected / target * 100, 100);\n};\nconst waitForConfirmation = async (client, txid)=>{\n    const status = await client.status().do();\n    let lastRound = status[\"last-round\"];\n    while(true){\n        try {\n            const pendingInfo = await client.pendingTransactionInformation(txid).do();\n            if (pendingInfo[\"confirmed-round\"] && pendingInfo[\"confirmed-round\"] > 0) {\n                return pendingInfo;\n            }\n            lastRound++;\n            await client.statusAfterBlock(lastRound).do();\n        } catch (e) {\n            console.error(\"Error waiting for confirmation:\", e);\n            throw e;\n        }\n    }\n};\nconst createProject = async (client, sender, privateKey, appId, projectData)=>{\n    const params = await client.getTransactionParams().do();\n    const appArgs = [\n        new Uint8Array(Buffer.from(\"create\")),\n        new Uint8Array(Buffer.from(projectData.name)),\n        new Uint8Array(Buffer.from(projectData.description)),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectData.targetAmount),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectData.deadline),\n        new Uint8Array(Buffer.from(projectData.category))\n    ];\n    const txn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxnFromObject({\n        from: sender,\n        appIndex: appId,\n        appArgs,\n        suggestedParams: params\n    });\n    const signed = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].signTransaction(txn, privateKey);\n    const res = await client.sendRawTransaction(signed.blob).do();\n    await waitForConfirmation(client, res.txid);\n    return res.txid;\n};\n// Build an unsigned app call txn for 'create' action to be signed by a wallet\nconst buildCreateProjectTxn = async (client, sender, appId, data)=>{\n    const params = await client.getTransactionParams().do();\n    const appArgs = [\n        new Uint8Array(Buffer.from(\"create\")),\n        new Uint8Array(Buffer.from(data.name)),\n        new Uint8Array(Buffer.from(data.description)),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(data.targetAmount),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(data.deadline),\n        new Uint8Array(Buffer.from(data.category))\n    ];\n    return algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxn(sender, params, appId, appArgs);\n};\n// Submit signed transaction bytes and wait for confirmation\nconst submitSignedTransaction = async (client, signed)=>{\n    const bytesArray = Array.isArray(signed) ? signed : [\n        signed\n    ];\n    const txId = await client.sendRawTransaction(bytesArray).do();\n    await waitForConfirmation(client, txId.txId);\n    return txId.txId;\n};\nconst contributeToProject = async (client, sender, privateKey, appId, projectId, amount)=>{\n    const params = await client.getTransactionParams().do();\n    // Get app address\n    const appInfo = await client.getApplicationByID(appId).do();\n    const appAddress = appInfo[\"params\"][\"creator\"];\n    // Create payment transaction\n    const paymentTxn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makePaymentTxnWithSuggestedParamsFromObject({\n        from: sender,\n        to: appAddress,\n        amount,\n        suggestedParams: params\n    });\n    // Create app call transaction\n    const appTxn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxnFromObject({\n        from: sender,\n        appIndex: appId,\n        appArgs: [\n            new Uint8Array(Buffer.from(\"contribute\")),\n            algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectId)\n        ],\n        suggestedParams: params\n    });\n    // Group transactions\n    const group = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assignGroupID([\n        paymentTxn,\n        appTxn\n    ]);\n    const signedPayment = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].signTransaction(paymentTxn, privateKey);\n    const signedApp = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].signTransaction(appTxn, privateKey);\n    const res = await client.sendRawTransaction([\n        signedPayment.blob,\n        signedApp.blob\n    ]).do();\n    await waitForConfirmation(client, res.txid);\n    return res.txid;\n};\n// Get projects from blockchain\nconst getProjects = async (client, appId)=>{\n    try {\n        console.log(\"\\uD83D\\uDD0D Getting app info for ID:\", appId);\n        const appInfo = await client.getApplicationByID(appId).do();\n        console.log(\"\\uD83D\\uDCF1 App info received:\", appInfo);\n        const globalState = appInfo.params[\"global-state\"] || appInfo.params.globalState || [];\n        console.log(\"\\uD83C\\uDF0D Global state:\", globalState);\n        // Debug: Print all keys\n        console.log(\"\\uD83D\\uDD11 All keys in global state:\");\n        globalState.forEach((item, index)=>{\n            const decodedKey = Buffer.from(item.key, \"base64\").toString();\n            const value = item.value.bytes ? Buffer.from(item.value.bytes, \"base64\").toString() : item.value.uint;\n            console.log(\"  \".concat(index, ': \"').concat(decodedKey, '\" = ').concat(value));\n        });\n        // Extract project count\n        const projectCountState = globalState.find((item)=>Buffer.from(item.key, \"base64\").toString() === \"project_count\");\n        const projectCount = projectCountState ? projectCountState.value.uint : 0;\n        console.log(\"\\uD83D\\uDCCA Project count found:\", projectCount);\n        const projects = [];\n        // Get each project's data\n        for(let i = 0; i < projectCount; i++){\n            console.log(\"\\uD83D\\uDD0D Processing project \".concat(i));\n            const getProjectValue = (suffix)=>{\n                // Exact key patterns from terminal output\n                const possibleKeys = [\n                    \"p__\".concat(suffix)\n                ];\n                for (const keyPattern of possibleKeys){\n                    const state = globalState.find((item)=>Buffer.from(item.key, \"base64\").toString() === keyPattern);\n                    if (state) {\n                        console.log(\"✅ Found key: \".concat(keyPattern, \" = \").concat(state.value.bytes ? Buffer.from(state.value.bytes, \"base64\").toString() : state.value.uint));\n                        return state.value.bytes ? Buffer.from(state.value.bytes, \"base64\").toString() : state.value.uint;\n                    }\n                }\n                console.log(\"❌ Key not found for suffix: \".concat(suffix, \", tried: \").concat(possibleKeys.join(\", \")));\n                return null;\n            };\n            const name = getProjectValue(\"name\");\n            const description = getProjectValue(\"desc\") || getProjectValue(\"description\") || \"No description available\";\n            const creator = getProjectValue(\"creator\");\n            const target = getProjectValue(\"target\");\n            const deadline = getProjectValue(\"deadline\") || Math.floor(Date.now() / 1000) + 86400 * 30 // Default 30 days\n            ;\n            const collected = getProjectValue(\"collected\") || 0;\n            const category = getProjectValue(\"category\") || \"General\";\n            const active = getProjectValue(\"active\") !== null ? getProjectValue(\"active\") : 1 // Default active\n            ;\n            console.log(\"\\uD83D\\uDCDD Project \".concat(i, \" extracted data:\"), {\n                name,\n                description,\n                creator,\n                target,\n                deadline,\n                collected,\n                category,\n                active\n            });\n            // Create project even if some fields are missing\n            if (name && target) {\n                projects.push({\n                    id: i,\n                    name,\n                    description,\n                    creator,\n                    targetAmount: target,\n                    deadline,\n                    collectedAmount: collected,\n                    category,\n                    threshold: 0,\n                    active: active === 1\n                });\n            }\n        }\n        return projects;\n    } catch (error) {\n        console.error(\"Error fetching projects:\", error);\n        return [];\n    }\n};\nconst withdrawFunds = async (client, sender, privateKey, appId, projectId)=>{\n    const params = await client.getTransactionParams().do();\n    const appArgs = [\n        new Uint8Array(Buffer.from(\"withdraw\")),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectId)\n    ];\n    const txn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxnFromObject({\n        from: sender,\n        appIndex: appId,\n        appArgs,\n        suggestedParams: params\n    });\n    const signed = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].signTransaction(txn, privateKey);\n    const res = await client.sendRawTransaction(signed.blob).do();\n    await waitForConfirmation(client, res.txid);\n    return res.txid;\n};\nconst claimRefund = async (client, sender, privateKey, appId, projectId)=>{\n    const params = await client.getTransactionParams().do();\n    const appArgs = [\n        new Uint8Array(Buffer.from(\"refund\")),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectId)\n    ];\n    const txn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxnFromObject({\n        from: sender,\n        appIndex: appId,\n        appArgs,\n        suggestedParams: params\n    });\n    const signed = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].signTransaction(txn, privateKey);\n    const res = await client.sendRawTransaction(signed.blob).do();\n    await waitForConfirmation(client, res.txid);\n    return res.txid;\n};\nconst mintRewardNFT = async (client, sender, privateKey, appId, projectId)=>{\n    const params = await client.getTransactionParams().do();\n    const appArgs = [\n        new Uint8Array(Buffer.from(\"mint_nft\")),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectId)\n    ];\n    const txn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxn(sender, params, appId, appArgs);\n    const signedTxn = txn.signTxn(privateKey);\n    const txId = await client.sendRawTransaction(signedTxn).do();\n    await waitForConfirmation(client, txId.txId);\n    return txId.txId;\n};\nconst optInToApp = async (client, sender, privateKey, appId)=>{\n    const params = await client.getTransactionParams().do();\n    const txn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationOptInTxnFromObject({\n        from: sender,\n        appIndex: appId,\n        suggestedParams: params\n    });\n    const signed = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].signTransaction(txn, privateKey);\n    const res = await client.sendRawTransaction(signed.blob).do();\n    await waitForConfirmation(client, res.txid);\n    return res.txid;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9hbGdvcmFuZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBRTdCLGlDQUFpQztBQUMxQixNQUFNQyxjQUFjLEdBQUU7QUFDdEIsTUFBTUMsZUFBZSxxQ0FBb0M7QUFDekQsTUFBTUMsYUFBYSxJQUFHO0FBRTdCLDRCQUE0QjtBQUNyQixNQUFNQyxTQUFTLFVBQVUsb0NBQW9DO0NBQXJDO0FBRXhCLE1BQU1DLGlCQUFpQjtJQUM1QixPQUFPLElBQUlMLHVEQUFlLENBQUNDLGFBQWFDLGNBQWNDO0FBQ3hELEVBQUM7QUFFTSxNQUFNSSxtQkFBbUIsQ0FBQ0M7SUFDL0IsT0FBTyxDQUFDQSxhQUFhLE9BQU0sRUFBR0MsT0FBTyxDQUFDO0FBQ3hDLEVBQUM7QUFFTSxNQUFNQyxrQkFBa0IsQ0FBQ0M7SUFDOUIsT0FBT0MsS0FBS0MsS0FBSyxDQUFDQyxXQUFXSCxTQUFTO0FBQ3hDLEVBQUM7QUFFTSxNQUFNSSxrQkFBa0IsQ0FBQ0M7SUFDOUIsT0FBTyxJQUFJQyxLQUFLRCxZQUFZLE1BQU1FLGtCQUFrQjtBQUN0RCxFQUFDO0FBRU0sTUFBTUMsbUJBQW1CLENBQUNDO0lBQy9CLE1BQU1DLE1BQU1ULEtBQUtDLEtBQUssQ0FBQ0ksS0FBS0ksR0FBRyxLQUFLO0lBQ3BDLE1BQU1DLFlBQVlGLFdBQVdDO0lBRTdCLElBQUlDLGFBQWEsR0FBRztRQUNsQixPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxPQUFPWCxLQUFLQyxLQUFLLENBQUNTLFlBQVk7SUFDcEMsTUFBTUUsUUFBUVosS0FBS0MsS0FBSyxDQUFDLFlBQWEsUUFBUztJQUMvQyxNQUFNWSxVQUFVYixLQUFLQyxLQUFLLENBQUMsWUFBYSxPQUFRO0lBRWhELElBQUlVLE9BQU8sR0FBRztRQUNaLE9BQU8sR0FBWUMsT0FBVEQsTUFBSyxNQUFjRSxPQUFWRCxPQUFNLE1BQVksT0FBUkMsU0FBUTtJQUN2QyxPQUFPLElBQUlE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QUFZL0QsSUFBSWdFLE9BQU8sQ0FBQzlFO0lBQzlCLE1BQU04QixPQUFPLE1BQU0zQyxPQUFPa0Msa0JBQWtCLENBQUN3RCxXQUFXdkYsRUFBRTtJQUUxRCxNQUFNSixvQkFBb0JDLFFBQVEyQyxLQUFLQSxJQUFJO0lBQzNDLE9BQU9BLEtBQUtBLElBQUk7QUFDbEIsRUFBQztBQUVNLE1BQU1pRCxhQUFhLE9BQ3hCNUYsUUFDQVksUUFDQUMsWUFDQUM7SUFFQSxNQUFNRSxTQUFTLE1BQU1oQixPQUFPaUIsb0JBQW9CLEdBQUdkLEVBQUU7SUFFckQsTUFBTXdCLE1BQU0xRCxpRkFBeUMsQ0FBQztRQUNwRG9ELE1BQU1UO1FBQ05pQixVQUFVZjtRQUNWZ0IsaUJBQWlCZDtJQUNuQjtJQUVBLE1BQU1lLFNBQVM5RCwrREFBdUIsQ0FBQzBELEtBQUtkO0lBQzVDLE1BQU1vQixNQUFNLE1BQU1qQyxPQUFPa0Msa0JBQWtCLENBQUNILE9BQU9JLElBQUksRUFBRWhDLEVBQUU7SUFFM0QsTUFBTUosb0JBQW9CQyxRQUFRaUMsSUFBSWhDLElBQUk7SUFDMUMsT0FBT2dDLElBQUloQyxJQUFJO0FBQ2pCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2FsZ29yYW5kLnRzPzViMTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFsZ29zZGsgZnJvbSAnYWxnb3NkaydcclxuXHJcbi8vIEFsZ29yYW5kIFRlc3RuZXQgY29uZmlndXJhdGlvblxyXG5leHBvcnQgY29uc3QgQUxHT0RfVE9LRU4gPSAnJ1xyXG5leHBvcnQgY29uc3QgQUxHT0RfU0VSVkVSID0gJ2h0dHBzOi8vdGVzdG5ldC1hcGkuYWxnb25vZGUuY2xvdWQnXHJcbmV4cG9ydCBjb25zdCBBTEdPRF9QT1JUID0gNDQzXHJcblxyXG4vLyBBcHBsaWNhdGlvbiBjb25maWd1cmF0aW9uXHJcbmV4cG9ydCBjb25zdCBBUFBfSUQgPSA3NDYxMDYxNTAgLy8gTGF0ZXN0IGRlcGxveWVkIHNtYXJ0IGNvbnRyYWN0IElEXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0QWxnb2RDbGllbnQgPSAoKSA9PiB7XHJcbiAgcmV0dXJuIG5ldyBhbGdvc2RrLkFsZ29kdjIoQUxHT0RfVE9LRU4sIEFMR09EX1NFUlZFUiwgQUxHT0RfUE9SVClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGZvcm1hdEFsZ29BbW91bnQgPSAobWljcm9BbGdvczogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICByZXR1cm4gKG1pY3JvQWxnb3MgLyAxMDAwMDAwKS50b0ZpeGVkKDIpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUFsZ29BbW91bnQgPSAoYWxnb3M6IHN0cmluZyk6IG51bWJlciA9PiB7XHJcbiAgcmV0dXJuIE1hdGguZmxvb3IocGFyc2VGbG9hdChhbGdvcykgKiAxMDAwMDAwKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZm9ybWF0VGltZXN0YW1wID0gKHRpbWVzdGFtcDogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICogMTAwMCkudG9Mb2NhbGVEYXRlU3RyaW5nKClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRpbWVSZW1haW5pbmcgPSAoZGVhZGxpbmU6IG51bWJlcik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMClcclxuICBjb25zdCByZW1haW5pbmcgPSBkZWFkbGluZSAtIG5vd1xyXG5cclxuICBpZiAocmVtYWluaW5nIDw9IDApIHtcclxuICAgIHJldHVybiAnRXhwaXJlZCdcclxuICB9XHJcblxyXG4gIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKHJlbWFpbmluZyAvIDg2NDAwKVxyXG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcigocmVtYWluaW5nICUgODY0MDApIC8gMzYwMClcclxuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcigocmVtYWluaW5nICUgMzYwMCkgLyA2MClcclxuXHJcbiAgaWYgKGRheXMgPiAwKSB7XHJcbiAgICByZXR1cm4gYCR7ZGF5c31kICR7aG91cnN9aCAke21pbnV0ZXN9bWBcclxuICB9IGVsc2UgaWYgKGhvdXJzID4gMCkge1xyXG4gICAgcmV0dXJuIGAke2hvdXJzfWggJHttaW51dGVzfW1gXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgJHttaW51dGVzfW1gXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UHJvZ3Jlc3NQZXJjZW50YWdlID0gKGNvbGxlY3RlZDogbnVtYmVyLCB0YXJnZXQ6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgaWYgKHRhcmdldCA9PT0gMCkgcmV0dXJuIDBcclxuICByZXR1cm4gTWF0aC5taW4oKGNvbGxlY3RlZCAvIHRhcmdldCkgKiAxMDAsIDEwMClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHdhaXRGb3JDb25maXJtYXRpb24gPSBhc3luYyAoY2xpZW50OiBhbGdvc2RrLkFsZ29kdjIsIHR4aWQ6IHN0cmluZyk6IFByb21pc2U8YWxnb3Nkay5QZW5kaW5nVHJhbnNhY3Rpb25JbmZvPiA9PiB7XHJcbiAgY29uc3Qgc3RhdHVzID0gYXdhaXQgY2xpZW50LnN0YXR1cygpLmRvKClcclxuICBsZXQgbGFzdFJvdW5kID0gc3RhdHVzWydsYXN0LXJvdW5kJ11cclxuXHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBlbmRpbmdJbmZvID0gYXdhaXQgY2xpZW50LnBlbmRpbmdUcmFuc2FjdGlvbkluZm9ybWF0aW9uKHR4aWQpLmRvKClcclxuICAgICAgaWYgKHBlbmRpbmdJbmZvWydjb25maXJtZWQtcm91bmQnXSAmJiBwZW5kaW5nSW5mb1snY29uZmlybWVkLXJvdW5kJ10gPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdJbmZvXHJcbiAgICAgIH1cclxuICAgICAgbGFzdFJvdW5kKytcclxuICAgICAgYXdhaXQgY2xpZW50LnN0YXR1c0FmdGVyQmxvY2sobGFzdFJvdW5kKS5kbygpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHdhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbjonLCBlKVxyXG4gICAgICB0aHJvdyBlXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlUHJvamVjdCA9IGFzeW5jIChcclxuICBjbGllbnQ6IGFsZ29zZGsuQWxnb2R2MixcclxuICBzZW5kZXI6IHN0cmluZyxcclxuICBwcml2YXRlS2V5OiBVaW50OEFycmF5LFxyXG4gIGFwcElkOiBudW1iZXIsXHJcbiAgcHJvamVjdERhdGE6IHtcclxuICAgIG5hbWU6IHN0cmluZ1xyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gICAgdGFyZ2V0QW1vdW50OiBudW1iZXJcclxuICAgIGRlYWRsaW5lOiBudW1iZXJcclxuICAgIGNhdGVnb3J5OiBzdHJpbmdcclxuICAgIHRocmVzaG9sZDogbnVtYmVyXHJcbiAgfVxyXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IHBhcmFtcyA9IGF3YWl0IGNsaWVudC5nZXRUcmFuc2FjdGlvblBhcmFtcygpLmRvKClcclxuXHJcbiAgY29uc3QgYXBwQXJncyA9IFtcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKCdjcmVhdGUnKSksIC8vIEZpeGVkOiAnY3JlYXRlJyBpbnN0ZWFkIG9mICdjcmVhdGVfcHJvamVjdCdcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHByb2plY3REYXRhLm5hbWUpKSxcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHByb2plY3REYXRhLmRlc2NyaXB0aW9uKSksXHJcbiAgICBhbGdvc2RrLmVuY29kZVVpbnQ2NChwcm9qZWN0RGF0YS50YXJnZXRBbW91bnQpLFxyXG4gICAgYWxnb3Nkay5lbmNvZGVVaW50NjQocHJvamVjdERhdGEuZGVhZGxpbmUpLFxyXG4gICAgbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20ocHJvamVjdERhdGEuY2F0ZWdvcnkpKVxyXG4gICAgLy8gUmVtb3ZlZCB0aHJlc2hvbGQgLSBiYWNrZW5kIGRvZXNuJ3Qgc3VwcG9ydCBpdFxyXG4gIF1cclxuXHJcbiAgY29uc3QgdHhuID0gYWxnb3Nkay5tYWtlQXBwbGljYXRpb25Ob09wVHhuRnJvbU9iamVjdCh7XHJcbiAgICBmcm9tOiBzZW5kZXIsXHJcbiAgICBhcHBJbmRleDogYXBwSWQsXHJcbiAgICBhcHBBcmdzLFxyXG4gICAgc3VnZ2VzdGVkUGFyYW1zOiBwYXJhbXNcclxuICB9KVxyXG5cclxuICBjb25zdCBzaWduZWQgPSBhbGdvc2RrLnNpZ25UcmFuc2FjdGlvbih0eG4sIHByaXZhdGVLZXkpXHJcbiAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWQuYmxvYikuZG8oKVxyXG5cclxuICBhd2FpdCB3YWl0Rm9yQ29uZmlybWF0aW9uKGNsaWVudCwgcmVzLnR4aWQpXHJcbiAgcmV0dXJuIHJlcy50eGlkXHJcbn1cclxuXHJcbi8vIFR5cGVzIGZvciBwcm9qZWN0IGNyZWF0aW9uXHJcbmV4cG9ydCB0eXBlIFByb2plY3RDcmVhdGVEYXRhID0ge1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICB0YXJnZXRBbW91bnQ6IG51bWJlciAvLyBpbiBtaWNyb0FsZ29zXHJcbiAgZGVhZGxpbmU6IG51bWJlciAvLyB1bml4IHNlY29uZHNcclxuICBjYXRlZ29yeTogc3RyaW5nXHJcbn1cclxuXHJcbi8vIEJ1aWxkIGFuIHVuc2lnbmVkIGFwcCBjYWxsIHR4biBmb3IgJ2NyZWF0ZScgYWN0aW9uIHRvIGJlIHNpZ25lZCBieSBhIHdhbGxldFxyXG5leHBvcnQgY29uc3QgYnVpbGRDcmVhdGVQcm9qZWN0VHhuID0gYXN5bmMgKFxyXG4gIGNsaWVudDogYWxnb3Nkay5BbGdvZHYyLFxyXG4gIHNlbmRlcjogc3RyaW5nLFxyXG4gIGFwcElkOiBudW1iZXIsXHJcbiAgZGF0YTogUHJvamVjdENyZWF0ZURhdGFcclxuKTogUHJvbWlzZTxhbGdvc2RrLlRyYW5zYWN0aW9uPiA9PiB7XHJcbiAgY29uc3QgcGFyYW1zID0gYXdhaXQgY2xpZW50LmdldFRyYW5zYWN0aW9uUGFyYW1zKCkuZG8oKVxyXG4gIGNvbnN0IGFwcEFyZ3MgPSBbXHJcbiAgICBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSgnY3JlYXRlJykpLFxyXG4gICAgbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oZGF0YS5uYW1lKSksXHJcbiAgICBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShkYXRhLmRlc2NyaXB0aW9uKSksXHJcbiAgICBhbGdvc2RrLmVuY29kZVVpbnQ2NChkYXRhLnRhcmdldEFtb3VudCksXHJcbiAgICBhbGdvc2RrLmVuY29kZVVpbnQ2NChkYXRhLmRlYWRsaW5lKSxcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKGRhdGEuY2F0ZWdvcnkpKVxyXG4gIF1cclxuXHJcbiAgcmV0dXJuIGFsZ29zZGsubWFrZUFwcGxpY2F0aW9uTm9PcFR4bihzZW5kZXIsIHBhcmFtcywgYXBwSWQsIGFwcEFyZ3MpXHJcbn1cclxuXHJcbi8vIFN1Ym1pdCBzaWduZWQgdHJhbnNhY3Rpb24gYnl0ZXMgYW5kIHdhaXQgZm9yIGNvbmZpcm1hdGlvblxyXG5leHBvcnQgY29uc3Qgc3VibWl0U2lnbmVkVHJhbnNhY3Rpb24gPSBhc3luYyAoXHJcbiAgY2xpZW50OiBhbGdvc2RrLkFsZ29kdjIsXHJcbiAgc2lnbmVkOiBVaW50OEFycmF5IHwgVWludDhBcnJheVtdXHJcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgY29uc3QgYnl0ZXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc2lnbmVkKSA/IHNpZ25lZCA6IFtzaWduZWRdXHJcbiAgY29uc3QgdHhJZCA9IGF3YWl0IGNsaWVudC5zZW5kUmF3VHJhbnNhY3Rpb24oYnl0ZXNBcnJheSkuZG8oKVxyXG4gIGF3YWl0IHdhaXRGb3JDb25maXJtYXRpb24oY2xpZW50LCB0eElkLnR4SWQpXHJcbiAgcmV0dXJuIHR4SWQudHhJZFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY29udHJpYnV0ZVRvUHJvamVjdCA9IGFzeW5jIChcclxuICBjbGllbnQ6IGFsZ29zZGsuQWxnb2R2MixcclxuICBzZW5kZXI6IHN0cmluZyxcclxuICBwcml2YXRlS2V5OiBVaW50OEFycmF5LFxyXG4gIGFwcElkOiBudW1iZXIsXHJcbiAgcHJvamVjdElkOiBudW1iZXIsXHJcbiAgYW1vdW50OiBudW1iZXJcclxuKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICBjb25zdCBwYXJhbXMgPSBhd2FpdCBjbGllbnQuZ2V0VHJhbnNhY3Rpb25QYXJhbXMoKS5kbygpXHJcblxyXG4gIC8vIEdldCBhcHAgYWRkcmVzc1xyXG4gIGNvbnN0IGFwcEluZm8gPSBhd2FpdCBjbGllbnQuZ2V0QXBwbGljYXRpb25CeUlEKGFwcElkKS5kbygpXHJcbiAgY29uc3QgYXBwQWRkcmVzcyA9IGFwcEluZm9bJ3BhcmFtcyddWydjcmVhdG9yJ11cclxuXHJcbiAgLy8gQ3JlYXRlIHBheW1lbnQgdHJhbnNhY3Rpb25cclxuICBjb25zdCBwYXltZW50VHhuID0gYWxnb3Nkay5tYWtlUGF5bWVudFR4bldpdGhTdWdnZXN0ZWRQYXJhbXNGcm9tT2JqZWN0KHtcclxuICAgIGZyb206IHNlbmRlcixcclxuICAgIHRvOiBhcHBBZGRyZXNzLFxyXG4gICAgYW1vdW50LFxyXG4gICAgc3VnZ2VzdGVkUGFyYW1zOiBwYXJhbXNcclxuICB9KVxyXG5cclxuICAvLyBDcmVhdGUgYXBwIGNhbGwgdHJhbnNhY3Rpb25cclxuICBjb25zdCBhcHBUeG4gPSBhbGdvc2RrLm1ha2VBcHBsaWNhdGlvbk5vT3BUeG5Gcm9tT2JqZWN0KHtcclxuICAgIGZyb206IHNlbmRlcixcclxuICAgIGFwcEluZGV4OiBhcHBJZCxcclxuICAgIGFwcEFyZ3M6IFtuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSgnY29udHJpYnV0ZScpKSwgYWxnb3Nkay5lbmNvZGVVaW50NjQocHJvamVjdElkKV0sXHJcbiAgICBzdWdnZXN0ZWRQYXJhbXM6IHBhcmFtc1xyXG4gIH0pXHJcblxyXG4gIC8vIEdyb3VwIHRyYW5zYWN0aW9uc1xyXG4gIGNvbnN0IGdyb3VwID0gYWxnb3Nkay5hc3NpZ25Hcm91cElEKFtwYXltZW50VHhuLCBhcHBUeG5dKVxyXG5cclxuICBjb25zdCBzaWduZWRQYXltZW50ID0gYWxnb3Nkay5zaWduVHJhbnNhY3Rpb24ocGF5bWVudFR4biwgcHJpdmF0ZUtleSlcclxuICBjb25zdCBzaWduZWRBcHAgPSBhbGdvc2RrLnNpZ25UcmFuc2FjdGlvbihhcHBUeG4sIHByaXZhdGVLZXkpXHJcblxyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5zZW5kUmF3VHJhbnNhY3Rpb24oW1xyXG4gICAgc2lnbmVkUGF5bWVudC5ibG9iLFxyXG4gICAgc2lnbmVkQXBwLmJsb2JcclxuICBdKS5kbygpXHJcblxyXG4gIGF3YWl0IHdhaXRGb3JDb25maXJtYXRpb24oY2xpZW50LCByZXMudHhpZClcclxuICByZXR1cm4gcmVzLnR4aWRcclxufVxyXG5cclxuLy8gR2V0IHByb2plY3RzIGZyb20gYmxvY2tjaGFpblxyXG5leHBvcnQgY29uc3QgZ2V0UHJvamVjdHMgPSBhc3luYyAoY2xpZW50OiBhbGdvc2RrLkFsZ29kdjIsIGFwcElkOiBudW1iZXIpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coJ/CflI0gR2V0dGluZyBhcHAgaW5mbyBmb3IgSUQ6JywgYXBwSWQpXHJcbiAgY29uc3QgYXBwSW5mbyA9IGF3YWl0IGNsaWVudC5nZXRBcHBsaWNhdGlvbkJ5SUQoYXBwSWQpLmRvKClcclxuICBjb25zb2xlLmxvZygn8J+TsSBBcHAgaW5mbyByZWNlaXZlZDonLCBhcHBJbmZvKVxyXG5cclxuICBjb25zdCBnbG9iYWxTdGF0ZSA9IChhcHBJbmZvLnBhcmFtcyBhcyBhbnkpWydnbG9iYWwtc3RhdGUnXSB8fCAoYXBwSW5mby5wYXJhbXMgYXMgYW55KS5nbG9iYWxTdGF0ZSB8fCBbXVxyXG4gICAgY29uc29sZS5sb2coJ/CfjI0gR2xvYmFsIHN0YXRlOicsIGdsb2JhbFN0YXRlKVxyXG5cclxuICAgIC8vIERlYnVnOiBQcmludCBhbGwga2V5c1xyXG4gICAgY29uc29sZS5sb2coJ/CflJEgQWxsIGtleXMgaW4gZ2xvYmFsIHN0YXRlOicpXHJcbiAgICBnbG9iYWxTdGF0ZS5mb3JFYWNoKChpdGVtOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgY29uc3QgZGVjb2RlZEtleSA9IEJ1ZmZlci5mcm9tKGl0ZW0ua2V5LCAnYmFzZTY0JykudG9TdHJpbmcoKVxyXG4gICAgICBjb25zdCB2YWx1ZSA9IGl0ZW0udmFsdWUuYnl0ZXNcclxuICAgICAgICA/IEJ1ZmZlci5mcm9tKGl0ZW0udmFsdWUuYnl0ZXMsICdiYXNlNjQnKS50b1N0cmluZygpXHJcbiAgICAgICAgOiBpdGVtLnZhbHVlLnVpbnRcclxuICAgICAgY29uc29sZS5sb2coYCAgJHtpbmRleH06IFwiJHtkZWNvZGVkS2V5fVwiID0gJHt2YWx1ZX1gKVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBFeHRyYWN0IHByb2plY3QgY291bnRcclxuICAgIGNvbnN0IHByb2plY3RDb3VudFN0YXRlID0gZ2xvYmFsU3RhdGUuZmluZCgoaXRlbTogYW55KSA9PlxyXG4gICAgICBCdWZmZXIuZnJvbShpdGVtLmtleSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCkgPT09ICdwcm9qZWN0X2NvdW50J1xyXG4gICAgKVxyXG4gICAgY29uc3QgcHJvamVjdENvdW50ID0gcHJvamVjdENvdW50U3RhdGUgPyBwcm9qZWN0Q291bnRTdGF0ZS52YWx1ZS51aW50IDogMFxyXG4gICAgY29uc29sZS5sb2coJ/Cfk4ogUHJvamVjdCBjb3VudCBmb3VuZDonLCBwcm9qZWN0Q291bnQpXHJcblxyXG4gICAgY29uc3QgcHJvamVjdHMgPSBbXVxyXG5cclxuICAgIC8vIEdldCBlYWNoIHByb2plY3QncyBkYXRhXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2plY3RDb3VudDsgaSsrKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFByb2Nlc3NpbmcgcHJvamVjdCAke2l9YClcclxuXHJcbiAgICAgIGNvbnN0IGdldFByb2plY3RWYWx1ZSA9IChzdWZmaXg6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIC8vIEV4YWN0IGtleSBwYXR0ZXJucyBmcm9tIHRlcm1pbmFsIG91dHB1dFxyXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlS2V5cyA9IFtcclxuICAgICAgICAgIGBwX18ke3N1ZmZpeH1gLCAgICAgICAgICAgIC8vIEFjdHVhbCBmb3JtYXQ6IHBfX25hbWUsIHBfX3RhcmdldCwgcF9fY29sbGVjdGVkLCBwX19jcmVhdG9yXHJcbiAgICAgICAgXVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGtleVBhdHRlcm4gb2YgcG9zc2libGVLZXlzKSB7XHJcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdsb2JhbFN0YXRlLmZpbmQoKGl0ZW06IGFueSkgPT5cclxuICAgICAgICAgICAgQnVmZmVyLmZyb20oaXRlbS5rZXksICdiYXNlNjQnKS50b1N0cmluZygpID09PSBrZXlQYXR0ZXJuXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBrZXk6ICR7a2V5UGF0dGVybn0gPSAke3N0YXRlLnZhbHVlLmJ5dGVzID8gQnVmZmVyLmZyb20oc3RhdGUudmFsdWUuYnl0ZXMsICdiYXNlNjQnKS50b1N0cmluZygpIDogc3RhdGUudmFsdWUudWludH1gKVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudmFsdWUuYnl0ZXMgPyBCdWZmZXIuZnJvbShzdGF0ZS52YWx1ZS5ieXRlcywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCkgOiBzdGF0ZS52YWx1ZS51aW50XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinYwgS2V5IG5vdCBmb3VuZCBmb3Igc3VmZml4OiAke3N1ZmZpeH0sIHRyaWVkOiAke3Bvc3NpYmxlS2V5cy5qb2luKCcsICcpfWApXHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbmFtZSA9IGdldFByb2plY3RWYWx1ZSgnbmFtZScpXHJcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZ2V0UHJvamVjdFZhbHVlKCdkZXNjJykgfHwgZ2V0UHJvamVjdFZhbHVlKCdkZXNjcmlwdGlvbicpIHx8ICdObyBkZXNjcmlwdGlvbiBhdmFpbGFibGUnXHJcbiAgICAgIGNvbnN0IGNyZWF0b3IgPSBnZXRQcm9qZWN0VmFsdWUoJ2NyZWF0b3InKVxyXG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm9qZWN0VmFsdWUoJ3RhcmdldCcpXHJcbiAgICAgIGNvbnN0IGRlYWRsaW5lID0gZ2V0UHJvamVjdFZhbHVlKCdkZWFkbGluZScpIHx8IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgODY0MDAgKiAzMCAvLyBEZWZhdWx0IDMwIGRheXNcclxuICAgICAgY29uc3QgY29sbGVjdGVkID0gZ2V0UHJvamVjdFZhbHVlKCdjb2xsZWN0ZWQnKSB8fCAwXHJcbiAgICAgIGNvbnN0IGNhdGVnb3J5ID0gZ2V0UHJvamVjdFZhbHVlKCdjYXRlZ29yeScpIHx8ICdHZW5lcmFsJ1xyXG4gICAgICBjb25zdCBhY3RpdmUgPSBnZXRQcm9qZWN0VmFsdWUoJ2FjdGl2ZScpICE9PSBudWxsID8gZ2V0UHJvamVjdFZhbHVlKCdhY3RpdmUnKSA6IDEgLy8gRGVmYXVsdCBhY3RpdmVcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIFByb2plY3QgJHtpfSBleHRyYWN0ZWQgZGF0YTpgLCB7XHJcbiAgICAgICAgbmFtZSwgZGVzY3JpcHRpb24sIGNyZWF0b3IsIHRhcmdldCwgZGVhZGxpbmUsIGNvbGxlY3RlZCwgY2F0ZWdvcnksIGFjdGl2ZVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgLy8gQ3JlYXRlIHByb2plY3QgZXZlbiBpZiBzb21lIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gICAgICBpZiAobmFtZSAmJiB0YXJnZXQpIHtcclxuICAgICAgICBwcm9qZWN0cy5wdXNoKHtcclxuICAgICAgICAgIGlkOiBpLFxyXG4gICAgICAgICAgbmFtZSxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgY3JlYXRvcixcclxuICAgICAgICAgIHRhcmdldEFtb3VudDogdGFyZ2V0LFxyXG4gICAgICAgICAgZGVhZGxpbmUsXHJcbiAgICAgICAgICBjb2xsZWN0ZWRBbW91bnQ6IGNvbGxlY3RlZCxcclxuICAgICAgICAgIGNhdGVnb3J5LFxyXG4gICAgICAgICAgdGhyZXNob2xkOiAwLCAvLyBOb3Qgc3RvcmVkIGluIHNpbXBsZSBjb250cmFjdFxyXG4gICAgICAgICAgYWN0aXZlOiBhY3RpdmUgPT09IDFcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByb2plY3RzXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2plY3RzOicsIGVycm9yKVxyXG4gICAgcmV0dXJuIFtdXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgd2l0aGRyYXdGdW5kcyA9IGFzeW5jIChcclxuICBjbGllbnQ6IGFsZ29zZGsuQWxnb2R2MixcclxuICBzZW5kZXI6IHN0cmluZyxcclxuICBwcml2YXRlS2V5OiBVaW50OEFycmF5LFxyXG4gIGFwcElkOiBudW1iZXIsXHJcbiAgcHJvamVjdElkOiBudW1iZXJcclxuKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICBjb25zdCBwYXJhbXMgPSBhd2FpdCBjbGllbnQuZ2V0VHJhbnNhY3Rpb25QYXJhbXMoKS5kbygpXHJcblxyXG4gIGNvbnN0IGFwcEFyZ3MgPSBbXHJcbiAgICBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSgnd2l0aGRyYXcnKSksXHJcbiAgICBhbGdvc2RrLmVuY29kZVVpbnQ2NChwcm9qZWN0SWQpXHJcbiAgXVxyXG5cclxuICBjb25zdCB0eG4gPSBhbGdvc2RrLm1ha2VBcHBsaWNhdGlvbk5vT3BUeG5Gcm9tT2JqZWN0KHtcclxuICAgIGZyb206IHNlbmRlcixcclxuICAgIGFwcEluZGV4OiBhcHBJZCxcclxuICAgIGFwcEFyZ3MsXHJcbiAgICBzdWdnZXN0ZWRQYXJhbXM6IHBhcmFtc1xyXG4gIH0pXHJcblxyXG4gIGNvbnN0IHNpZ25lZCA9IGFsZ29zZGsuc2lnblRyYW5zYWN0aW9uKHR4biwgcHJpdmF0ZUtleSlcclxuICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQuc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZC5ibG9iKS5kbygpXHJcblxyXG4gIGF3YWl0IHdhaXRGb3JDb25maXJtYXRpb24oY2xpZW50LCByZXMudHhpZClcclxuICByZXR1cm4gcmVzLnR4aWRcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNsYWltUmVmdW5kID0gYXN5bmMgKFxyXG4gIGNsaWVudDogYWxnb3Nkay5BbGdvZHYyLFxyXG4gIHNlbmRlcjogc3RyaW5nLFxyXG4gIHByaXZhdGVLZXk6IFVpbnQ4QXJyYXksXHJcbiAgYXBwSWQ6IG51bWJlcixcclxuICBwcm9qZWN0SWQ6IG51bWJlclxyXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IHBhcmFtcyA9IGF3YWl0IGNsaWVudC5nZXRUcmFuc2FjdGlvblBhcmFtcygpLmRvKClcclxuXHJcbiAgY29uc3QgYXBwQXJncyA9IFtcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKCdyZWZ1bmQnKSksXHJcbiAgICBhbGdvc2RrLmVuY29kZVVpbnQ2NChwcm9qZWN0SWQpXHJcbiAgXVxyXG5cclxuICBjb25zdCB0eG4gPSBhbGdvc2RrLm1ha2VBcHBsaWNhdGlvbk5vT3BUeG5Gcm9tT2JqZWN0KHtcclxuICAgIGZyb206IHNlbmRlcixcclxuICAgIGFwcEluZGV4OiBhcHBJZCxcclxuICAgIGFwcEFyZ3MsXHJcbiAgICBzdWdnZXN0ZWRQYXJhbXM6IHBhcmFtc1xyXG4gIH0pXHJcblxyXG4gIGNvbnN0IHNpZ25lZCA9IGFsZ29zZGsuc2lnblRyYW5zYWN0aW9uKHR4biwgcHJpdmF0ZUtleSlcclxuICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQuc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZC5ibG9iKS5kbygpXHJcblxyXG4gIGF3YWl0IHdhaXRGb3JDb25maXJtYXRpb24oY2xpZW50LCByZXMudHhpZClcclxuICByZXR1cm4gcmVzLnR4aWRcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG1pbnRSZXdhcmRORlQgPSBhc3luYyAoXHJcbiAgY2xpZW50OiBhbGdvc2RrLkFsZ29kdjIsXHJcbiAgc2VuZGVyOiBzdHJpbmcsXHJcbiAgcHJpdmF0ZUtleTogVWludDhBcnJheSxcclxuICBhcHBJZDogbnVtYmVyLFxyXG4gIHByb2plY3RJZDogbnVtYmVyXHJcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgY29uc3QgcGFyYW1zID0gYXdhaXQgY2xpZW50LmdldFRyYW5zYWN0aW9uUGFyYW1zKCkuZG8oKVxyXG5cclxuICBjb25zdCBhcHBBcmdzID0gW1xyXG4gICAgbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oJ21pbnRfbmZ0JykpLFxyXG4gICAgYWxnb3Nkay5lbmNvZGVVaW50NjQocHJvamVjdElkKVxyXG4gIF1cclxuXHJcbiAgY29uc3QgdHhuID0gYWxnb3Nkay5tYWtlQXBwbGljYXRpb25Ob09wVHhuKFxyXG4gICAgc2VuZGVyLFxyXG4gICAgcGFyYW1zLFxyXG4gICAgYXBwSWQsXHJcbiAgICBhcHBBcmdzXHJcbiAgKVxyXG5cclxuICBjb25zdCBzaWduZWRUeG4gPSB0eG4uc2lnblR4bihwcml2YXRlS2V5KVxyXG4gIGNvbnN0IHR4SWQgPSBhd2FpdCBjbGllbnQuc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFR4bikuZG8oKVxyXG5cclxuICBhd2FpdCB3YWl0Rm9yQ29uZmlybWF0aW9uKGNsaWVudCwgdHhJZC50eElkKVxyXG4gIHJldHVybiB0eElkLnR4SWRcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG9wdEluVG9BcHAgPSBhc3luYyAoXHJcbiAgY2xpZW50OiBhbGdvc2RrLkFsZ29kdjIsXHJcbiAgc2VuZGVyOiBzdHJpbmcsXHJcbiAgcHJpdmF0ZUtleTogVWludDhBcnJheSxcclxuICBhcHBJZDogbnVtYmVyXHJcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgY29uc3QgcGFyYW1zID0gYXdhaXQgY2xpZW50LmdldFRyYW5zYWN0aW9uUGFyYW1zKCkuZG8oKVxyXG5cclxuICBjb25zdCB0eG4gPSBhbGdvc2RrLm1ha2VBcHBsaWNhdGlvbk9wdEluVHhuRnJvbU9iamVjdCh7XHJcbiAgICBmcm9tOiBzZW5kZXIsXHJcbiAgICBhcHBJbmRleDogYXBwSWQsXHJcbiAgICBzdWdnZXN0ZWRQYXJhbXM6IHBhcmFtc1xyXG4gIH0pXHJcblxyXG4gIGNvbnN0IHNpZ25lZCA9IGFsZ29zZGsuc2lnblRyYW5zYWN0aW9uKHR4biwgcHJpdmF0ZUtleSlcclxuICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQuc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZC5ibG9iKS5kbygpXHJcblxyXG4gIGF3YWl0IHdhaXRGb3JDb25maXJtYXRpb24oY2xpZW50LCByZXMudHhpZClcclxuICByZXR1cm4gcmVzLnR4aWRcclxufVxyXG4iXSwibmFtZXMiOlsiYWxnb3NkayIsIkFMR09EX1RPS0VOIiwiQUxHT0RfU0VSVkVSIiwiQUxHT0RfUE9SVCIsIkFQUF9JRCIsImdldEFsZ29kQ2xpZW50IiwiQWxnb2R2MiIsImZvcm1hdEFsZ29BbW91bnQiLCJtaWNyb0FsZ29zIiwidG9GaXhlZCIsInBhcnNlQWxnb0Ftb3VudCIsImFsZ29zIiwiTWF0aCIsImZsb29yIiwicGFyc2VGbG9hdCIsImZvcm1hdFRpbWVzdGFtcCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJnZXRUaW1lUmVtYWluaW5nIiwiZGVhZGxpbmUiLCJub3ciLCJyZW1haW5pbmciLCJkYXlzIiwiaG91cnMiLCJtaW51dGVzIiwiZ2V0UHJvZ3Jlc3NQZXJjZW50YWdlIiwiY29sbGVjdGVkIiwidGFyZ2V0IiwibWluIiwid2FpdEZvckNvbmZpcm1hdGlvbiIsImNsaWVudCIsInR4aWQiLCJzdGF0dXMiLCJkbyIsImxhc3RSb3VuZCIsInBlbmRpbmdJbmZvIiwicGVuZGluZ1RyYW5zYWN0aW9uSW5mb3JtYXRpb24iLCJzdGF0dXNBZnRlckJsb2NrIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImNyZWF0ZVByb2plY3QiLCJzZW5kZXIiLCJwcml2YXRlS2V5IiwiYXBwSWQiLCJwcm9qZWN0RGF0YSIsInBhcmFtcyIsImdldFRyYW5zYWN0aW9uUGFyYW1zIiwiYXBwQXJncyIsIlVpbnQ4QXJyYXkiLCJCdWZmZXIiLCJmcm9tIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiZW5jb2RlVWludDY0IiwidGFyZ2V0QW1vdW50IiwiY2F0ZWdvcnkiLCJ0eG4iLCJtYWtlQXBwbGljYXRpb25Ob09wVHhuRnJvbU9iamVjdCIsImFwcEluZGV4Iiwic3VnZ2VzdGVkUGFyYW1zIiwic2lnbmVkIiwic2lnblRyYW5zYWN0aW9uIiwicmVzIiwic2VuZFJhd1RyYW5zYWN0aW9uIiwiYmxvYiIsImJ1aWxkQ3JlYXRlUHJvamVjdFR4biIsImRhdGEiLCJtYWtlQXBwbGljYXRpb25Ob09wVHhuIiwic3VibWl0U2lnbmVkVHJhbnNhY3Rpb24iLCJieXRlc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwidHhJZCIsImNvbnRyaWJ1dGVUb1Byb2plY3QiLCJwcm9qZWN0SWQiLCJhbW91bnQiLCJhcHBJbmZvIiwiZ2V0QXBwbGljYXRpb25CeUlEIiwiYXBwQWRkcmVzcyIsInBheW1lbnRUeG4iLCJtYWtlUGF5bWVudFR4bldpdGhTdWdnZXN0ZWRQYXJhbXNGcm9tT2JqZWN0IiwidG8iLCJhcHBUeG4iLCJncm91cCIsImFzc2lnbkdyb3VwSUQiLCJzaWduZWRQYXltZW50Iiwic2lnbmVkQXBwIiwiZ2V0UHJvamVjdHMiLCJsb2ciLCJnbG9iYWxTdGF0ZSIsImZvckVhY2giLCJpdGVtIiwiaW5kZXgiLCJkZWNvZGVkS2V5Iiwia2V5IiwidG9TdHJpbmciLCJ2YWx1ZSIsImJ5dGVzIiwidWludCIsInByb2plY3RDb3VudFN0YXRlIiwiZmluZCIsInByb2plY3RDb3VudCIsInByb2plY3RzIiwiaSIsImdldFByb2plY3RWYWx1ZSIsInN1ZmZpeCIsInBvc3NpYmxlS2V5cyIsImtleVBhdHRlcm4iLCJzdGF0ZSIsImpvaW4iLCJjcmVhdG9yIiwiYWN0aXZlIiwicHVzaCIsImlkIiwiY29sbGVjdGVkQW1vdW50IiwidGhyZXNob2xkIiwid2l0aGRyYXdGdW5kcyIsImNsYWltUmVmdW5kIiwibWludFJld2FyZE5GVCIsInNpZ25lZFR4biIsInNpZ25UeG4iLCJvcHRJblRvQXBwIiwibWFrZUFwcGxpY2F0aW9uT3B0SW5UeG5Gcm9tT2JqZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/algorand.ts\n"));

/***/ })

});