"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/algorand.ts":
/*!*******************************!*\
  !*** ./src/utils/algorand.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALGOD_PORT: function() { return /* binding */ ALGOD_PORT; },\n/* harmony export */   ALGOD_SERVER: function() { return /* binding */ ALGOD_SERVER; },\n/* harmony export */   ALGOD_TOKEN: function() { return /* binding */ ALGOD_TOKEN; },\n/* harmony export */   APP_ID: function() { return /* binding */ APP_ID; },\n/* harmony export */   buildCreateProjectTxn: function() { return /* binding */ buildCreateProjectTxn; },\n/* harmony export */   claimRefund: function() { return /* binding */ claimRefund; },\n/* harmony export */   contributeToProject: function() { return /* binding */ contributeToProject; },\n/* harmony export */   createProject: function() { return /* binding */ createProject; },\n/* harmony export */   formatAlgoAmount: function() { return /* binding */ formatAlgoAmount; },\n/* harmony export */   formatTimestamp: function() { return /* binding */ formatTimestamp; },\n/* harmony export */   getAlgodClient: function() { return /* binding */ getAlgodClient; },\n/* harmony export */   getProgressPercentage: function() { return /* binding */ getProgressPercentage; },\n/* harmony export */   getProjects: function() { return /* binding */ getProjects; },\n/* harmony export */   getTimeRemaining: function() { return /* binding */ getTimeRemaining; },\n/* harmony export */   mintRewardNFT: function() { return /* binding */ mintRewardNFT; },\n/* harmony export */   optInToApp: function() { return /* binding */ optInToApp; },\n/* harmony export */   parseAlgoAmount: function() { return /* binding */ parseAlgoAmount; },\n/* harmony export */   submitSignedTransaction: function() { return /* binding */ submitSignedTransaction; },\n/* harmony export */   waitForConfirmation: function() { return /* binding */ waitForConfirmation; },\n/* harmony export */   withdrawFunds: function() { return /* binding */ withdrawFunds; }\n/* harmony export */ });\n/* harmony import */ var algosdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! algosdk */ \"(app-pages-browser)/./node_modules/algosdk/dist/esm/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n// Algorand Testnet configuration\nconst ALGOD_TOKEN = \"\";\nconst ALGOD_SERVER = \"https://testnet-api.algonode.cloud\";\nconst ALGOD_PORT = 443;\n// Application configuration\nconst APP_ID = 746106150 // Latest deployed smart contract ID\n;\nconst getAlgodClient = ()=>{\n    return new algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Algodv2(ALGOD_TOKEN, ALGOD_SERVER, ALGOD_PORT);\n};\nconst formatAlgoAmount = (microAlgos)=>{\n    return (microAlgos / 1000000).toFixed(2);\n};\nconst parseAlgoAmount = (algos)=>{\n    return Math.floor(parseFloat(algos) * 1000000);\n};\nconst formatTimestamp = (timestamp)=>{\n    return new Date(timestamp * 1000).toLocaleDateString();\n};\nconst getTimeRemaining = (deadline)=>{\n    const now = Math.floor(Date.now() / 1000);\n    const remaining = deadline - now;\n    if (remaining <= 0) {\n        return \"Expired\";\n    }\n    const days = Math.floor(remaining / 86400);\n    const hours = Math.floor(remaining % 86400 / 3600);\n    const minutes = Math.floor(remaining % 3600 / 60);\n    if (days > 0) {\n        return \"\".concat(days, \"d \").concat(hours, \"h \").concat(minutes, \"m\");\n    } else if (hours > 0) {\n        return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n    } else {\n        return \"\".concat(minutes, \"m\");\n    }\n};\nconst getProgressPercentage = (collected, target)=>{\n    if (target === 0) return 0;\n    return Math.min(collected / target * 100, 100);\n};\nconst waitForConfirmation = async (client, txid)=>{\n    const status = await client.status().do();\n    let lastRound = status[\"last-round\"];\n    while(true){\n        try {\n            const pendingInfo = await client.pendingTransactionInformation(txid).do();\n            if (pendingInfo[\"confirmed-round\"] && pendingInfo[\"confirmed-round\"] > 0) {\n                return pendingInfo;\n            }\n            lastRound++;\n            await client.statusAfterBlock(lastRound).do();\n        } catch (e) {\n            console.error(\"Error waiting for confirmation:\", e);\n            throw e;\n        }\n    }\n};\nconst createProject = async (client, sender, privateKey, appId, projectData)=>{\n    const params = await client.getTransactionParams().do();\n    const appArgs = [\n        new Uint8Array(Buffer.from(\"create\")),\n        new Uint8Array(Buffer.from(projectData.name)),\n        new Uint8Array(Buffer.from(projectData.description)),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectData.targetAmount),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectData.deadline),\n        new Uint8Array(Buffer.from(projectData.category))\n    ];\n    const txn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxn(sender, params, appId, appArgs);\n    const signedTxn = txn.signTxn(privateKey);\n    const txId = await client.sendRawTransaction(signedTxn).do();\n    await waitForConfirmation(client, txId.txId);\n    return txId.txId;\n};\n// Build an unsigned app call txn for 'create' action to be signed by a wallet\nconst buildCreateProjectTxn = async (client, sender, appId, data)=>{\n    const params = await client.getTransactionParams().do();\n    const appArgs = [\n        new Uint8Array(Buffer.from(\"create\")),\n        new Uint8Array(Buffer.from(data.name)),\n        new Uint8Array(Buffer.from(data.description)),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(data.targetAmount),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(data.deadline),\n        new Uint8Array(Buffer.from(data.category))\n    ];\n    return algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxn(sender, params, appId, appArgs);\n};\n// Submit signed transaction bytes and wait for confirmation\nconst submitSignedTransaction = async (client, signed)=>{\n    const bytesArray = Array.isArray(signed) ? signed : [\n        signed\n    ];\n    const txId = await client.sendRawTransaction(bytesArray).do();\n    await waitForConfirmation(client, txId.txId);\n    return txId.txId;\n};\nconst contributeToProject = async (client, sender, privateKey, appId, projectId, amount)=>{\n    const params = await client.getTransactionParams().do();\n    // Get app address\n    const appInfo = await client.getApplicationByID(appId).do();\n    const appAddress = appInfo[\"params\"][\"creator\"];\n    // Create payment transaction\n    const paymentTxn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makePaymentTxnWithSuggestedParams(sender, appAddress, amount, undefined, undefined, params);\n    // Create app call transaction\n    const appTxn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxn(sender, params, appId, [\n        new Uint8Array(Buffer.from(\"contribute\")),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectId)\n    ]);\n    // Group transactions\n    const group = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assignGroupID([\n        paymentTxn,\n        appTxn\n    ]);\n    const signedPayment = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].signTransaction(paymentTxn, privateKey);\n    const signedApp = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].signTransaction(appTxn, privateKey);\n    const txId = await client.sendRawTransaction([\n        signedPayment.blob,\n        signedApp.blob\n    ]).do();\n    await waitForConfirmation(client, txId.txId);\n    return txId.txId;\n};\n// Get projects from blockchain\nconst getProjects = async (client, appId)=>{\n    try {\n        console.log(\"\\uD83D\\uDD0D Getting app info for ID:\", appId);\n        const appInfo = await client.getApplicationByID(appId).do();\n        console.log(\"\\uD83D\\uDCF1 App info received:\", appInfo);\n        const globalState = appInfo.params.globalState || appInfo.params[\"global-state\"] || [];\n        console.log(\"\\uD83C\\uDF0D Global state:\", globalState);\n        // Debug: Print all keys\n        console.log(\"\\uD83D\\uDD11 All keys in global state:\");\n        globalState.forEach((item, index)=>{\n            const decodedKey = Buffer.from(item.key, \"base64\").toString();\n            const value = item.value.bytes ? Buffer.from(item.value.bytes, \"base64\").toString() : item.value.uint;\n            console.log(\"  \".concat(index, ': \"').concat(decodedKey, '\" = ').concat(value));\n        });\n        // Extract project count\n        const projectCountState = globalState.find((item)=>Buffer.from(item.key, \"base64\").toString() === \"project_count\");\n        const projectCount = projectCountState ? projectCountState.value.uint : 0;\n        console.log(\"\\uD83D\\uDCCA Project count found:\", projectCount);\n        const projects = [];\n        // Get each project's data\n        for(let i = 0; i < projectCount; i++){\n            console.log(\"\\uD83D\\uDD0D Processing project \".concat(i));\n            const getProjectValue = (suffix)=>{\n                // Exact key patterns from terminal output\n                const possibleKeys = [\n                    \"p__\".concat(suffix)\n                ];\n                for (const keyPattern of possibleKeys){\n                    const state = globalState.find((item)=>Buffer.from(item.key, \"base64\").toString() === keyPattern);\n                    if (state) {\n                        console.log(\"✅ Found key: \".concat(keyPattern, \" = \").concat(state.value.bytes ? Buffer.from(state.value.bytes, \"base64\").toString() : state.value.uint));\n                        return state.value.bytes ? Buffer.from(state.value.bytes, \"base64\").toString() : state.value.uint;\n                    }\n                }\n                console.log(\"❌ Key not found for suffix: \".concat(suffix, \", tried: \").concat(possibleKeys.join(\", \")));\n                return null;\n            };\n            const name = getProjectValue(\"name\");\n            const description = getProjectValue(\"desc\") || getProjectValue(\"description\") || \"No description available\";\n            const creator = getProjectValue(\"creator\");\n            const target = getProjectValue(\"target\");\n            const deadline = getProjectValue(\"deadline\") || Math.floor(Date.now() / 1000) + 86400 * 30 // Default 30 days\n            ;\n            const collected = getProjectValue(\"collected\") || 0;\n            const category = getProjectValue(\"category\") || \"General\";\n            const active = getProjectValue(\"active\") !== null ? getProjectValue(\"active\") : 1 // Default active\n            ;\n            console.log(\"\\uD83D\\uDCDD Project \".concat(i, \" extracted data:\"), {\n                name,\n                description,\n                creator,\n                target,\n                deadline,\n                collected,\n                category,\n                active\n            });\n            // Create project even if some fields are missing\n            if (name && target) {\n                projects.push({\n                    id: i,\n                    name,\n                    description,\n                    creator,\n                    targetAmount: target,\n                    deadline,\n                    collectedAmount: collected,\n                    category,\n                    threshold: 0,\n                    active: active === 1\n                });\n            }\n        }\n        return projects;\n    } catch (error) {\n        console.error(\"Error fetching projects:\", error);\n        return [];\n    }\n};\nconst withdrawFunds = async (client, sender, privateKey, appId, projectId)=>{\n    const params = await client.getTransactionParams().do();\n    const appArgs = [\n        new Uint8Array(Buffer.from(\"withdraw\")),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectId)\n    ];\n    const txn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxn(sender, params, appId, appArgs);\n    const signedTxn = txn.signTxn(privateKey);\n    const txId = await client.sendRawTransaction(signedTxn).do();\n    await waitForConfirmation(client, txId.txId);\n    return txId.txId;\n};\nconst claimRefund = async (client, sender, privateKey, appId, projectId)=>{\n    const params = await client.getTransactionParams().do();\n    const appArgs = [\n        new Uint8Array(Buffer.from(\"refund\")),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectId)\n    ];\n    const txn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxn(sender, params, appId, appArgs);\n    const signedTxn = txn.signTxn(privateKey);\n    const txId = await client.sendRawTransaction(signedTxn).do();\n    await waitForConfirmation(client, txId.txId);\n    return txId.txId;\n};\nconst mintRewardNFT = async (client, sender, privateKey, appId, projectId)=>{\n    const params = await client.getTransactionParams().do();\n    const appArgs = [\n        new Uint8Array(Buffer.from(\"mint_nft\")),\n        algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeUint64(projectId)\n    ];\n    const txn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationNoOpTxn(sender, params, appId, appArgs);\n    const signedTxn = txn.signTxn(privateKey);\n    const txId = await client.sendRawTransaction(signedTxn).do();\n    await waitForConfirmation(client, txId.txId);\n    return txId.txId;\n};\nconst optInToApp = async (client, sender, privateKey, appId)=>{\n    const params = await client.getTransactionParams().do();\n    const txn = algosdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeApplicationOptInTxn(sender, params, appId);\n    const signedTxn = txn.signTxn(privateKey);\n    const txId = await client.sendRawTransaction(signedTxn).do();\n    await waitForConfirmation(client, txId.txId);\n    return txId.txId;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9hbGdvcmFuZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBRTdCLGlDQUFpQztBQUMxQixNQUFNQyxjQUFjLEdBQUU7QUFDdEIsTUFBTUMsZUFBZSxxQ0FBb0M7QUFDekQsTUFBTUMsYUFBYSxJQUFHO0FBRTdCLDRCQUE0QjtBQUNyQixNQUFNQyxTQUFTLFVBQVUsb0NBQW9DO0NBQXJDO0FBRXhCLE1BQU1DLGlCQUFpQjtJQUM1QixPQUFPLElBQUlMLHVEQUFlLENBQUNDLGFBQWFDLGNBQWNDO0FBQ3hELEVBQUM7QUFFTSxNQUFNSSxtQkFBbUIsQ0FBQ0M7SUFDL0IsT0FBTyxDQUFDQSxhQUFhLE9BQU0sRUFBR0MsT0FBTyxDQUFDO0FBQ3hDLEVBQUM7QUFFTSxNQUFNQyxrQkFBa0IsQ0FBQ0M7SUFDOUIsT0FBT0MsS0FBS0MsS0FBSyxDQUFDQyxXQUFXSCxTQUFTO0FBQ3hDLEVBQUM7QUFFTSxNQUFNSSxrQkFBa0IsQ0FBQ0M7SUFDOUIsT0FBTyxJQUFJQyxLQUFLRCxZQUFZLE1BQU1FLGtCQUFrQjtBQUN0RCxFQUFDO0FBRU0sTUFBTUMsbUJBQW1CLENBQUNDO0lBQy9CLE1BQU1DLE1BQU1ULEtBQUtDLEtBQUssQ0FBQ0ksS0FBS0ksR0FBRyxLQUFLO0lBQ3BDLE1BQU1DLFlBQVlGLFdBQVdDO0lBRTdCLElBQUlDLGFBQWEsR0FBRztRQUNsQixPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxPQUFPWCxLQUFLQyxLQUFLLENBQUNTLFlBQVk7SUFDcEMsTUFBTUUsUUFBUVosS0FBS0MsS0FBSyxDQUFDLFlBQWEsUUFBUztJQUMvQyxNQUFNWSxVQUFVYixLQUFLQyxLQUFLLENBQUMsWUFBYSxPQUFRO0lBRWhELElBQUlVLE9BQU8sR0FBRztRQUNaLE9BQU8sR0FBWUMsT0FBVEQsTUFBSyxNQUFjRSxPQUFWRCxPQUFNLE1BQVksT0FBUkMsU0FBUTtJQUN2QyxPQUFPLElBQUlE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RUFBQztBQUVNLE1BQU15RCxhQUFhLE9BQ3hCeEYsUUFDQVksUUFDQUMsWUFDQUM7SUFFQSxNQUFNRSxTQUFTLE1BQU1oQixPQUFPaUIsb0JBQW9CLEdBQUdkLEVBQUU7SUFFckQsTUFBTXdCLE1BQU0xRCwrQ0FBT0EsQ0FBQ3dILHVCQUF1QixDQUN6QzdFLFFBQ0FJLFFBQ0FGO0lBR0YsTUFBTWUsWUFBWUYsSUFBSUcsT0FBTyxDQUFDakI7SUFDOUIsTUFBTWtCLE9BQU8sTUFBTS9CLE9BQU9nQyxrQkFBa0IsQ0FBQ0gsV0FBVzFCLEVBQUU7SUFFMUQsTUFBTUosb0JBQW9CQyxRQUFRK0IsS0FBS0EsSUFBSTtJQUMzQyxPQUFPQSxLQUFLQSxJQUFJO0FBQ2xCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2FsZ29yYW5kLnRzPzViMTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFsZ29zZGsgZnJvbSAnYWxnb3NkaydcclxuXHJcbi8vIEFsZ29yYW5kIFRlc3RuZXQgY29uZmlndXJhdGlvblxyXG5leHBvcnQgY29uc3QgQUxHT0RfVE9LRU4gPSAnJ1xyXG5leHBvcnQgY29uc3QgQUxHT0RfU0VSVkVSID0gJ2h0dHBzOi8vdGVzdG5ldC1hcGkuYWxnb25vZGUuY2xvdWQnXHJcbmV4cG9ydCBjb25zdCBBTEdPRF9QT1JUID0gNDQzXHJcblxyXG4vLyBBcHBsaWNhdGlvbiBjb25maWd1cmF0aW9uXHJcbmV4cG9ydCBjb25zdCBBUFBfSUQgPSA3NDYxMDYxNTAgLy8gTGF0ZXN0IGRlcGxveWVkIHNtYXJ0IGNvbnRyYWN0IElEXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0QWxnb2RDbGllbnQgPSAoKSA9PiB7XHJcbiAgcmV0dXJuIG5ldyBhbGdvc2RrLkFsZ29kdjIoQUxHT0RfVE9LRU4sIEFMR09EX1NFUlZFUiwgQUxHT0RfUE9SVClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGZvcm1hdEFsZ29BbW91bnQgPSAobWljcm9BbGdvczogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICByZXR1cm4gKG1pY3JvQWxnb3MgLyAxMDAwMDAwKS50b0ZpeGVkKDIpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUFsZ29BbW91bnQgPSAoYWxnb3M6IHN0cmluZyk6IG51bWJlciA9PiB7XHJcbiAgcmV0dXJuIE1hdGguZmxvb3IocGFyc2VGbG9hdChhbGdvcykgKiAxMDAwMDAwKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZm9ybWF0VGltZXN0YW1wID0gKHRpbWVzdGFtcDogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICogMTAwMCkudG9Mb2NhbGVEYXRlU3RyaW5nKClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRpbWVSZW1haW5pbmcgPSAoZGVhZGxpbmU6IG51bWJlcik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMClcclxuICBjb25zdCByZW1haW5pbmcgPSBkZWFkbGluZSAtIG5vd1xyXG5cclxuICBpZiAocmVtYWluaW5nIDw9IDApIHtcclxuICAgIHJldHVybiAnRXhwaXJlZCdcclxuICB9XHJcblxyXG4gIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKHJlbWFpbmluZyAvIDg2NDAwKVxyXG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcigocmVtYWluaW5nICUgODY0MDApIC8gMzYwMClcclxuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcigocmVtYWluaW5nICUgMzYwMCkgLyA2MClcclxuXHJcbiAgaWYgKGRheXMgPiAwKSB7XHJcbiAgICByZXR1cm4gYCR7ZGF5c31kICR7aG91cnN9aCAke21pbnV0ZXN9bWBcclxuICB9IGVsc2UgaWYgKGhvdXJzID4gMCkge1xyXG4gICAgcmV0dXJuIGAke2hvdXJzfWggJHttaW51dGVzfW1gXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgJHttaW51dGVzfW1gXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UHJvZ3Jlc3NQZXJjZW50YWdlID0gKGNvbGxlY3RlZDogbnVtYmVyLCB0YXJnZXQ6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgaWYgKHRhcmdldCA9PT0gMCkgcmV0dXJuIDBcclxuICByZXR1cm4gTWF0aC5taW4oKGNvbGxlY3RlZCAvIHRhcmdldCkgKiAxMDAsIDEwMClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHdhaXRGb3JDb25maXJtYXRpb24gPSBhc3luYyAoY2xpZW50OiBhbGdvc2RrLkFsZ29kdjIsIHR4aWQ6IHN0cmluZyk6IFByb21pc2U8YWxnb3Nkay5QZW5kaW5nVHJhbnNhY3Rpb25JbmZvPiA9PiB7XHJcbiAgY29uc3Qgc3RhdHVzID0gYXdhaXQgY2xpZW50LnN0YXR1cygpLmRvKClcclxuICBsZXQgbGFzdFJvdW5kID0gc3RhdHVzWydsYXN0LXJvdW5kJ11cclxuXHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBlbmRpbmdJbmZvID0gYXdhaXQgY2xpZW50LnBlbmRpbmdUcmFuc2FjdGlvbkluZm9ybWF0aW9uKHR4aWQpLmRvKClcclxuICAgICAgaWYgKHBlbmRpbmdJbmZvWydjb25maXJtZWQtcm91bmQnXSAmJiBwZW5kaW5nSW5mb1snY29uZmlybWVkLXJvdW5kJ10gPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdJbmZvXHJcbiAgICAgIH1cclxuICAgICAgbGFzdFJvdW5kKytcclxuICAgICAgYXdhaXQgY2xpZW50LnN0YXR1c0FmdGVyQmxvY2sobGFzdFJvdW5kKS5kbygpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHdhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbjonLCBlKVxyXG4gICAgICB0aHJvdyBlXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlUHJvamVjdCA9IGFzeW5jIChcclxuICBjbGllbnQ6IGFsZ29zZGsuQWxnb2R2MixcclxuICBzZW5kZXI6IHN0cmluZyxcclxuICBwcml2YXRlS2V5OiBVaW50OEFycmF5LFxyXG4gIGFwcElkOiBudW1iZXIsXHJcbiAgcHJvamVjdERhdGE6IHtcclxuICAgIG5hbWU6IHN0cmluZ1xyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gICAgdGFyZ2V0QW1vdW50OiBudW1iZXJcclxuICAgIGRlYWRsaW5lOiBudW1iZXJcclxuICAgIGNhdGVnb3J5OiBzdHJpbmdcclxuICAgIHRocmVzaG9sZDogbnVtYmVyXHJcbiAgfVxyXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IHBhcmFtcyA9IGF3YWl0IGNsaWVudC5nZXRUcmFuc2FjdGlvblBhcmFtcygpLmRvKClcclxuXHJcbiAgY29uc3QgYXBwQXJncyA9IFtcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKCdjcmVhdGUnKSksIC8vIEZpeGVkOiAnY3JlYXRlJyBpbnN0ZWFkIG9mICdjcmVhdGVfcHJvamVjdCdcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHByb2plY3REYXRhLm5hbWUpKSxcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHByb2plY3REYXRhLmRlc2NyaXB0aW9uKSksXHJcbiAgICBhbGdvc2RrLmVuY29kZVVpbnQ2NChwcm9qZWN0RGF0YS50YXJnZXRBbW91bnQpLFxyXG4gICAgYWxnb3Nkay5lbmNvZGVVaW50NjQocHJvamVjdERhdGEuZGVhZGxpbmUpLFxyXG4gICAgbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20ocHJvamVjdERhdGEuY2F0ZWdvcnkpKVxyXG4gICAgLy8gUmVtb3ZlZCB0aHJlc2hvbGQgLSBiYWNrZW5kIGRvZXNuJ3Qgc3VwcG9ydCBpdFxyXG4gIF1cclxuXHJcbiAgY29uc3QgdHhuID0gYWxnb3Nkay5tYWtlQXBwbGljYXRpb25Ob09wVHhuKFxyXG4gICAgc2VuZGVyLFxyXG4gICAgcGFyYW1zLFxyXG4gICAgYXBwSWQsXHJcbiAgICBhcHBBcmdzXHJcbiAgKVxyXG5cclxuICBjb25zdCBzaWduZWRUeG4gPSB0eG4uc2lnblR4bihwcml2YXRlS2V5KVxyXG4gIGNvbnN0IHR4SWQgPSBhd2FpdCBjbGllbnQuc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFR4bikuZG8oKVxyXG5cclxuICBhd2FpdCB3YWl0Rm9yQ29uZmlybWF0aW9uKGNsaWVudCwgdHhJZC50eElkKVxyXG4gIHJldHVybiB0eElkLnR4SWRcclxufVxyXG5cclxuLy8gVHlwZXMgZm9yIHByb2plY3QgY3JlYXRpb25cclxuZXhwb3J0IHR5cGUgUHJvamVjdENyZWF0ZURhdGEgPSB7XHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gIHRhcmdldEFtb3VudDogbnVtYmVyIC8vIGluIG1pY3JvQWxnb3NcclxuICBkZWFkbGluZTogbnVtYmVyIC8vIHVuaXggc2Vjb25kc1xyXG4gIGNhdGVnb3J5OiBzdHJpbmdcclxufVxyXG5cclxuLy8gQnVpbGQgYW4gdW5zaWduZWQgYXBwIGNhbGwgdHhuIGZvciAnY3JlYXRlJyBhY3Rpb24gdG8gYmUgc2lnbmVkIGJ5IGEgd2FsbGV0XHJcbmV4cG9ydCBjb25zdCBidWlsZENyZWF0ZVByb2plY3RUeG4gPSBhc3luYyAoXHJcbiAgY2xpZW50OiBhbGdvc2RrLkFsZ29kdjIsXHJcbiAgc2VuZGVyOiBzdHJpbmcsXHJcbiAgYXBwSWQ6IG51bWJlcixcclxuICBkYXRhOiBQcm9qZWN0Q3JlYXRlRGF0YVxyXG4pOiBQcm9taXNlPGFsZ29zZGsuVHJhbnNhY3Rpb24+ID0+IHtcclxuICBjb25zdCBwYXJhbXMgPSBhd2FpdCBjbGllbnQuZ2V0VHJhbnNhY3Rpb25QYXJhbXMoKS5kbygpXHJcbiAgY29uc3QgYXBwQXJncyA9IFtcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKCdjcmVhdGUnKSksXHJcbiAgICBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShkYXRhLm5hbWUpKSxcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKGRhdGEuZGVzY3JpcHRpb24pKSxcclxuICAgIGFsZ29zZGsuZW5jb2RlVWludDY0KGRhdGEudGFyZ2V0QW1vdW50KSxcclxuICAgIGFsZ29zZGsuZW5jb2RlVWludDY0KGRhdGEuZGVhZGxpbmUpLFxyXG4gICAgbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oZGF0YS5jYXRlZ29yeSkpXHJcbiAgXVxyXG5cclxuICByZXR1cm4gYWxnb3Nkay5tYWtlQXBwbGljYXRpb25Ob09wVHhuKHNlbmRlciwgcGFyYW1zLCBhcHBJZCwgYXBwQXJncylcclxufVxyXG5cclxuLy8gU3VibWl0IHNpZ25lZCB0cmFuc2FjdGlvbiBieXRlcyBhbmQgd2FpdCBmb3IgY29uZmlybWF0aW9uXHJcbmV4cG9ydCBjb25zdCBzdWJtaXRTaWduZWRUcmFuc2FjdGlvbiA9IGFzeW5jIChcclxuICBjbGllbnQ6IGFsZ29zZGsuQWxnb2R2MixcclxuICBzaWduZWQ6IFVpbnQ4QXJyYXkgfCBVaW50OEFycmF5W11cclxuKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICBjb25zdCBieXRlc0FycmF5ID0gQXJyYXkuaXNBcnJheShzaWduZWQpID8gc2lnbmVkIDogW3NpZ25lZF1cclxuICBjb25zdCB0eElkID0gYXdhaXQgY2xpZW50LnNlbmRSYXdUcmFuc2FjdGlvbihieXRlc0FycmF5KS5kbygpXHJcbiAgYXdhaXQgd2FpdEZvckNvbmZpcm1hdGlvbihjbGllbnQsIHR4SWQudHhJZClcclxuICByZXR1cm4gdHhJZC50eElkXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjb250cmlidXRlVG9Qcm9qZWN0ID0gYXN5bmMgKFxyXG4gIGNsaWVudDogYWxnb3Nkay5BbGdvZHYyLFxyXG4gIHNlbmRlcjogc3RyaW5nLFxyXG4gIHByaXZhdGVLZXk6IFVpbnQ4QXJyYXksXHJcbiAgYXBwSWQ6IG51bWJlcixcclxuICBwcm9qZWN0SWQ6IG51bWJlcixcclxuICBhbW91bnQ6IG51bWJlclxyXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IHBhcmFtcyA9IGF3YWl0IGNsaWVudC5nZXRUcmFuc2FjdGlvblBhcmFtcygpLmRvKClcclxuXHJcbiAgLy8gR2V0IGFwcCBhZGRyZXNzXHJcbiAgY29uc3QgYXBwSW5mbyA9IGF3YWl0IGNsaWVudC5nZXRBcHBsaWNhdGlvbkJ5SUQoYXBwSWQpLmRvKClcclxuICBjb25zdCBhcHBBZGRyZXNzID0gYXBwSW5mb1sncGFyYW1zJ11bJ2NyZWF0b3InXVxyXG5cclxuICAvLyBDcmVhdGUgcGF5bWVudCB0cmFuc2FjdGlvblxyXG4gIGNvbnN0IHBheW1lbnRUeG4gPSBhbGdvc2RrLm1ha2VQYXltZW50VHhuV2l0aFN1Z2dlc3RlZFBhcmFtcyhcclxuICAgIHNlbmRlcixcclxuICAgIGFwcEFkZHJlc3MsXHJcbiAgICBhbW91bnQsXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICBwYXJhbXNcclxuICApXHJcblxyXG4gIC8vIENyZWF0ZSBhcHAgY2FsbCB0cmFuc2FjdGlvblxyXG4gIGNvbnN0IGFwcFR4biA9IGFsZ29zZGsubWFrZUFwcGxpY2F0aW9uTm9PcFR4bihcclxuICAgIHNlbmRlcixcclxuICAgIHBhcmFtcyxcclxuICAgIGFwcElkLFxyXG4gICAgW25ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKCdjb250cmlidXRlJykpLCBhbGdvc2RrLmVuY29kZVVpbnQ2NChwcm9qZWN0SWQpXVxyXG4gIClcclxuXHJcbiAgLy8gR3JvdXAgdHJhbnNhY3Rpb25zXHJcbiAgY29uc3QgZ3JvdXAgPSBhbGdvc2RrLmFzc2lnbkdyb3VwSUQoW3BheW1lbnRUeG4sIGFwcFR4bl0pXHJcblxyXG4gIGNvbnN0IHNpZ25lZFBheW1lbnQgPSBhbGdvc2RrLnNpZ25UcmFuc2FjdGlvbihwYXltZW50VHhuLCBwcml2YXRlS2V5KVxyXG4gIGNvbnN0IHNpZ25lZEFwcCA9IGFsZ29zZGsuc2lnblRyYW5zYWN0aW9uKGFwcFR4biwgcHJpdmF0ZUtleSlcclxuXHJcbiAgY29uc3QgdHhJZCA9IGF3YWl0IGNsaWVudC5zZW5kUmF3VHJhbnNhY3Rpb24oW1xyXG4gICAgc2lnbmVkUGF5bWVudC5ibG9iLFxyXG4gICAgc2lnbmVkQXBwLmJsb2JcclxuICBdKS5kbygpXHJcblxyXG4gIGF3YWl0IHdhaXRGb3JDb25maXJtYXRpb24oY2xpZW50LCB0eElkLnR4SWQpXHJcbiAgcmV0dXJuIHR4SWQudHhJZFxyXG59XHJcblxyXG4vLyBHZXQgcHJvamVjdHMgZnJvbSBibG9ja2NoYWluXHJcbmV4cG9ydCBjb25zdCBnZXRQcm9qZWN0cyA9IGFzeW5jIChjbGllbnQ6IGFsZ29zZGsuQWxnb2R2MiwgYXBwSWQ6IG51bWJlcikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+UjSBHZXR0aW5nIGFwcCBpbmZvIGZvciBJRDonLCBhcHBJZClcclxuICAgIGNvbnN0IGFwcEluZm8gPSBhd2FpdCBjbGllbnQuZ2V0QXBwbGljYXRpb25CeUlEKGFwcElkKS5kbygpXHJcbiAgICBjb25zb2xlLmxvZygn8J+TsSBBcHAgaW5mbyByZWNlaXZlZDonLCBhcHBJbmZvKVxyXG5cclxuICAgIGNvbnN0IGdsb2JhbFN0YXRlID0gYXBwSW5mby5wYXJhbXMuZ2xvYmFsU3RhdGUgfHwgYXBwSW5mby5wYXJhbXNbJ2dsb2JhbC1zdGF0ZSddIHx8IFtdXHJcbiAgICBjb25zb2xlLmxvZygn8J+MjSBHbG9iYWwgc3RhdGU6JywgZ2xvYmFsU3RhdGUpXHJcblxyXG4gICAgLy8gRGVidWc6IFByaW50IGFsbCBrZXlzXHJcbiAgICBjb25zb2xlLmxvZygn8J+UkSBBbGwga2V5cyBpbiBnbG9iYWwgc3RhdGU6JylcclxuICAgIGdsb2JhbFN0YXRlLmZvckVhY2goKGl0ZW06IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICBjb25zdCBkZWNvZGVkS2V5ID0gQnVmZmVyLmZyb20oaXRlbS5rZXksICdiYXNlNjQnKS50b1N0cmluZygpXHJcbiAgICAgIGNvbnN0IHZhbHVlID0gaXRlbS52YWx1ZS5ieXRlc1xyXG4gICAgICAgID8gQnVmZmVyLmZyb20oaXRlbS52YWx1ZS5ieXRlcywgJ2Jhc2U2NCcpLnRvU3RyaW5nKClcclxuICAgICAgICA6IGl0ZW0udmFsdWUudWludFxyXG4gICAgICBjb25zb2xlLmxvZyhgICAke2luZGV4fTogXCIke2RlY29kZWRLZXl9XCIgPSAke3ZhbHVlfWApXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIEV4dHJhY3QgcHJvamVjdCBjb3VudFxyXG4gICAgY29uc3QgcHJvamVjdENvdW50U3RhdGUgPSBnbG9iYWxTdGF0ZS5maW5kKChpdGVtOiBhbnkpID0+XHJcbiAgICAgIEJ1ZmZlci5mcm9tKGl0ZW0ua2V5LCAnYmFzZTY0JykudG9TdHJpbmcoKSA9PT0gJ3Byb2plY3RfY291bnQnXHJcbiAgICApXHJcbiAgICBjb25zdCBwcm9qZWN0Q291bnQgPSBwcm9qZWN0Q291bnRTdGF0ZSA/IHByb2plY3RDb3VudFN0YXRlLnZhbHVlLnVpbnQgOiAwXHJcbiAgICBjb25zb2xlLmxvZygn8J+TiiBQcm9qZWN0IGNvdW50IGZvdW5kOicsIHByb2plY3RDb3VudClcclxuXHJcbiAgICBjb25zdCBwcm9qZWN0cyA9IFtdXHJcblxyXG4gICAgLy8gR2V0IGVhY2ggcHJvamVjdCdzIGRhdGFcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvamVjdENvdW50OyBpKyspIHtcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gUHJvY2Vzc2luZyBwcm9qZWN0ICR7aX1gKVxyXG5cclxuICAgICAgY29uc3QgZ2V0UHJvamVjdFZhbHVlID0gKHN1ZmZpeDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgLy8gRXhhY3Qga2V5IHBhdHRlcm5zIGZyb20gdGVybWluYWwgb3V0cHV0XHJcbiAgICAgICAgY29uc3QgcG9zc2libGVLZXlzID0gW1xyXG4gICAgICAgICAgYHBfXyR7c3VmZml4fWAsICAgICAgICAgICAgLy8gQWN0dWFsIGZvcm1hdDogcF9fbmFtZSwgcF9fdGFyZ2V0LCBwX19jb2xsZWN0ZWQsIHBfX2NyZWF0b3JcclxuICAgICAgICBdXHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5UGF0dGVybiBvZiBwb3NzaWJsZUtleXMpIHtcclxuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2xvYmFsU3RhdGUuZmluZCgoaXRlbTogYW55KSA9PlxyXG4gICAgICAgICAgICBCdWZmZXIuZnJvbShpdGVtLmtleSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCkgPT09IGtleVBhdHRlcm5cclxuICAgICAgICAgIClcclxuICAgICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGtleTogJHtrZXlQYXR0ZXJufSA9ICR7c3RhdGUudmFsdWUuYnl0ZXMgPyBCdWZmZXIuZnJvbShzdGF0ZS52YWx1ZS5ieXRlcywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCkgOiBzdGF0ZS52YWx1ZS51aW50fWApXHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS52YWx1ZS5ieXRlcyA/IEJ1ZmZlci5mcm9tKHN0YXRlLnZhbHVlLmJ5dGVzLCAnYmFzZTY0JykudG9TdHJpbmcoKSA6IHN0YXRlLnZhbHVlLnVpbnRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKdjCBLZXkgbm90IGZvdW5kIGZvciBzdWZmaXg6ICR7c3VmZml4fSwgdHJpZWQ6ICR7cG9zc2libGVLZXlzLmpvaW4oJywgJyl9YClcclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBuYW1lID0gZ2V0UHJvamVjdFZhbHVlKCduYW1lJylcclxuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBnZXRQcm9qZWN0VmFsdWUoJ2Rlc2MnKSB8fCBnZXRQcm9qZWN0VmFsdWUoJ2Rlc2NyaXB0aW9uJykgfHwgJ05vIGRlc2NyaXB0aW9uIGF2YWlsYWJsZSdcclxuICAgICAgY29uc3QgY3JlYXRvciA9IGdldFByb2plY3RWYWx1ZSgnY3JlYXRvcicpXHJcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFByb2plY3RWYWx1ZSgndGFyZ2V0JylcclxuICAgICAgY29uc3QgZGVhZGxpbmUgPSBnZXRQcm9qZWN0VmFsdWUoJ2RlYWRsaW5lJykgfHwgTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyA4NjQwMCAqIDMwIC8vIERlZmF1bHQgMzAgZGF5c1xyXG4gICAgICBjb25zdCBjb2xsZWN0ZWQgPSBnZXRQcm9qZWN0VmFsdWUoJ2NvbGxlY3RlZCcpIHx8IDBcclxuICAgICAgY29uc3QgY2F0ZWdvcnkgPSBnZXRQcm9qZWN0VmFsdWUoJ2NhdGVnb3J5JykgfHwgJ0dlbmVyYWwnXHJcbiAgICAgIGNvbnN0IGFjdGl2ZSA9IGdldFByb2plY3RWYWx1ZSgnYWN0aXZlJykgIT09IG51bGwgPyBnZXRQcm9qZWN0VmFsdWUoJ2FjdGl2ZScpIDogMSAvLyBEZWZhdWx0IGFjdGl2ZVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCfk50gUHJvamVjdCAke2l9IGV4dHJhY3RlZCBkYXRhOmAsIHtcclxuICAgICAgICBuYW1lLCBkZXNjcmlwdGlvbiwgY3JlYXRvciwgdGFyZ2V0LCBkZWFkbGluZSwgY29sbGVjdGVkLCBjYXRlZ29yeSwgYWN0aXZlXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICAvLyBDcmVhdGUgcHJvamVjdCBldmVuIGlmIHNvbWUgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAgICAgIGlmIChuYW1lICYmIHRhcmdldCkge1xyXG4gICAgICAgIHByb2plY3RzLnB1c2goe1xyXG4gICAgICAgICAgaWQ6IGksXHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICBjcmVhdG9yLFxyXG4gICAgICAgICAgdGFyZ2V0QW1vdW50OiB0YXJnZXQsXHJcbiAgICAgICAgICBkZWFkbGluZSxcclxuICAgICAgICAgIGNvbGxlY3RlZEFtb3VudDogY29sbGVjdGVkLFxyXG4gICAgICAgICAgY2F0ZWdvcnksXHJcbiAgICAgICAgICB0aHJlc2hvbGQ6IDAsIC8vIE5vdCBzdG9yZWQgaW4gc2ltcGxlIGNvbnRyYWN0XHJcbiAgICAgICAgICBhY3RpdmU6IGFjdGl2ZSA9PT0gMVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcHJvamVjdHNcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvamVjdHM6JywgZXJyb3IpXHJcbiAgICByZXR1cm4gW11cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB3aXRoZHJhd0Z1bmRzID0gYXN5bmMgKFxyXG4gIGNsaWVudDogYWxnb3Nkay5BbGdvZHYyLFxyXG4gIHNlbmRlcjogc3RyaW5nLFxyXG4gIHByaXZhdGVLZXk6IFVpbnQ4QXJyYXksXHJcbiAgYXBwSWQ6IG51bWJlcixcclxuICBwcm9qZWN0SWQ6IG51bWJlclxyXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IHBhcmFtcyA9IGF3YWl0IGNsaWVudC5nZXRUcmFuc2FjdGlvblBhcmFtcygpLmRvKClcclxuXHJcbiAgY29uc3QgYXBwQXJncyA9IFtcclxuICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKCd3aXRoZHJhdycpKSxcclxuICAgIGFsZ29zZGsuZW5jb2RlVWludDY0KHByb2plY3RJZClcclxuICBdXHJcblxyXG4gIGNvbnN0IHR4biA9IGFsZ29zZGsubWFrZUFwcGxpY2F0aW9uTm9PcFR4bihcclxuICAgIHNlbmRlcixcclxuICAgIHBhcmFtcyxcclxuICAgIGFwcElkLFxyXG4gICAgYXBwQXJnc1xyXG4gIClcclxuXHJcbiAgY29uc3Qgc2lnbmVkVHhuID0gdHhuLnNpZ25UeG4ocHJpdmF0ZUtleSlcclxuICBjb25zdCB0eElkID0gYXdhaXQgY2xpZW50LnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeG4pLmRvKClcclxuXHJcbiAgYXdhaXQgd2FpdEZvckNvbmZpcm1hdGlvbihjbGllbnQsIHR4SWQudHhJZClcclxuICByZXR1cm4gdHhJZC50eElkXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjbGFpbVJlZnVuZCA9IGFzeW5jIChcclxuICBjbGllbnQ6IGFsZ29zZGsuQWxnb2R2MixcclxuICBzZW5kZXI6IHN0cmluZyxcclxuICBwcml2YXRlS2V5OiBVaW50OEFycmF5LFxyXG4gIGFwcElkOiBudW1iZXIsXHJcbiAgcHJvamVjdElkOiBudW1iZXJcclxuKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICBjb25zdCBwYXJhbXMgPSBhd2FpdCBjbGllbnQuZ2V0VHJhbnNhY3Rpb25QYXJhbXMoKS5kbygpXHJcblxyXG4gIGNvbnN0IGFwcEFyZ3MgPSBbXHJcbiAgICBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSgncmVmdW5kJykpLFxyXG4gICAgYWxnb3Nkay5lbmNvZGVVaW50NjQocHJvamVjdElkKVxyXG4gIF1cclxuXHJcbiAgY29uc3QgdHhuID0gYWxnb3Nkay5tYWtlQXBwbGljYXRpb25Ob09wVHhuKFxyXG4gICAgc2VuZGVyLFxyXG4gICAgcGFyYW1zLFxyXG4gICAgYXBwSWQsXHJcbiAgICBhcHBBcmdzXHJcbiAgKVxyXG5cclxuICBjb25zdCBzaWduZWRUeG4gPSB0eG4uc2lnblR4bihwcml2YXRlS2V5KVxyXG4gIGNvbnN0IHR4SWQgPSBhd2FpdCBjbGllbnQuc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFR4bikuZG8oKVxyXG5cclxuICBhd2FpdCB3YWl0Rm9yQ29uZmlybWF0aW9uKGNsaWVudCwgdHhJZC50eElkKVxyXG4gIHJldHVybiB0eElkLnR4SWRcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG1pbnRSZXdhcmRORlQgPSBhc3luYyAoXHJcbiAgY2xpZW50OiBhbGdvc2RrLkFsZ29kdjIsXHJcbiAgc2VuZGVyOiBzdHJpbmcsXHJcbiAgcHJpdmF0ZUtleTogVWludDhBcnJheSxcclxuICBhcHBJZDogbnVtYmVyLFxyXG4gIHByb2plY3RJZDogbnVtYmVyXHJcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgY29uc3QgcGFyYW1zID0gYXdhaXQgY2xpZW50LmdldFRyYW5zYWN0aW9uUGFyYW1zKCkuZG8oKVxyXG5cclxuICBjb25zdCBhcHBBcmdzID0gW1xyXG4gICAgbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oJ21pbnRfbmZ0JykpLFxyXG4gICAgYWxnb3Nkay5lbmNvZGVVaW50NjQocHJvamVjdElkKVxyXG4gIF1cclxuXHJcbiAgY29uc3QgdHhuID0gYWxnb3Nkay5tYWtlQXBwbGljYXRpb25Ob09wVHhuKFxyXG4gICAgc2VuZGVyLFxyXG4gICAgcGFyYW1zLFxyXG4gICAgYXBwSWQsXHJcbiAgICBhcHBBcmdzXHJcbiAgKVxyXG5cclxuICBjb25zdCBzaWduZWRUeG4gPSB0eG4uc2lnblR4bihwcml2YXRlS2V5KVxyXG4gIGNvbnN0IHR4SWQgPSBhd2FpdCBjbGllbnQuc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFR4bikuZG8oKVxyXG5cclxuICBhd2FpdCB3YWl0Rm9yQ29uZmlybWF0aW9uKGNsaWVudCwgdHhJZC50eElkKVxyXG4gIHJldHVybiB0eElkLnR4SWRcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG9wdEluVG9BcHAgPSBhc3luYyAoXHJcbiAgY2xpZW50OiBhbGdvc2RrLkFsZ29kdjIsXHJcbiAgc2VuZGVyOiBzdHJpbmcsXHJcbiAgcHJpdmF0ZUtleTogVWludDhBcnJheSxcclxuICBhcHBJZDogbnVtYmVyXHJcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgY29uc3QgcGFyYW1zID0gYXdhaXQgY2xpZW50LmdldFRyYW5zYWN0aW9uUGFyYW1zKCkuZG8oKVxyXG5cclxuICBjb25zdCB0eG4gPSBhbGdvc2RrLm1ha2VBcHBsaWNhdGlvbk9wdEluVHhuKFxyXG4gICAgc2VuZGVyLFxyXG4gICAgcGFyYW1zLFxyXG4gICAgYXBwSWRcclxuICApXHJcblxyXG4gIGNvbnN0IHNpZ25lZFR4biA9IHR4bi5zaWduVHhuKHByaXZhdGVLZXkpXHJcbiAgY29uc3QgdHhJZCA9IGF3YWl0IGNsaWVudC5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHhuKS5kbygpXHJcblxyXG4gIGF3YWl0IHdhaXRGb3JDb25maXJtYXRpb24oY2xpZW50LCB0eElkLnR4SWQpXHJcbiAgcmV0dXJuIHR4SWQudHhJZFxyXG59XHJcbiJdLCJuYW1lcyI6WyJhbGdvc2RrIiwiQUxHT0RfVE9LRU4iLCJBTEdPRF9TRVJWRVIiLCJBTEdPRF9QT1JUIiwiQVBQX0lEIiwiZ2V0QWxnb2RDbGllbnQiLCJBbGdvZHYyIiwiZm9ybWF0QWxnb0Ftb3VudCIsIm1pY3JvQWxnb3MiLCJ0b0ZpeGVkIiwicGFyc2VBbGdvQW1vdW50IiwiYWxnb3MiLCJNYXRoIiwiZmxvb3IiLCJwYXJzZUZsb2F0IiwiZm9ybWF0VGltZXN0YW1wIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsImdldFRpbWVSZW1haW5pbmciLCJkZWFkbGluZSIsIm5vdyIsInJlbWFpbmluZyIsImRheXMiLCJob3VycyIsIm1pbnV0ZXMiLCJnZXRQcm9ncmVzc1BlcmNlbnRhZ2UiLCJjb2xsZWN0ZWQiLCJ0YXJnZXQiLCJtaW4iLCJ3YWl0Rm9yQ29uZmlybWF0aW9uIiwiY2xpZW50IiwidHhpZCIsInN0YXR1cyIsImRvIiwibGFzdFJvdW5kIiwicGVuZGluZ0luZm8iLCJwZW5kaW5nVHJhbnNhY3Rpb25JbmZvcm1hdGlvbiIsInN0YXR1c0FmdGVyQmxvY2siLCJlIiwiY29uc29sZSIsImVycm9yIiwiY3JlYXRlUHJvamVjdCIsInNlbmRlciIsInByaXZhdGVLZXkiLCJhcHBJZCIsInByb2plY3REYXRhIiwicGFyYW1zIiwiZ2V0VHJhbnNhY3Rpb25QYXJhbXMiLCJhcHBBcmdzIiwiVWludDhBcnJheSIsIkJ1ZmZlciIsImZyb20iLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJlbmNvZGVVaW50NjQiLCJ0YXJnZXRBbW91bnQiLCJjYXRlZ29yeSIsInR4biIsIm1ha2VBcHBsaWNhdGlvbk5vT3BUeG4iLCJzaWduZWRUeG4iLCJzaWduVHhuIiwidHhJZCIsInNlbmRSYXdUcmFuc2FjdGlvbiIsImJ1aWxkQ3JlYXRlUHJvamVjdFR4biIsImRhdGEiLCJzdWJtaXRTaWduZWRUcmFuc2FjdGlvbiIsInNpZ25lZCIsImJ5dGVzQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJjb250cmlidXRlVG9Qcm9qZWN0IiwicHJvamVjdElkIiwiYW1vdW50IiwiYXBwSW5mbyIsImdldEFwcGxpY2F0aW9uQnlJRCIsImFwcEFkZHJlc3MiLCJwYXltZW50VHhuIiwibWFrZVBheW1lbnRUeG5XaXRoU3VnZ2VzdGVkUGFyYW1zIiwidW5kZWZpbmVkIiwiYXBwVHhuIiwiZ3JvdXAiLCJhc3NpZ25Hcm91cElEIiwic2lnbmVkUGF5bWVudCIsInNpZ25UcmFuc2FjdGlvbiIsInNpZ25lZEFwcCIsImJsb2IiLCJnZXRQcm9qZWN0cyIsImxvZyIsImdsb2JhbFN0YXRlIiwiZm9yRWFjaCIsIml0ZW0iLCJpbmRleCIsImRlY29kZWRLZXkiLCJrZXkiLCJ0b1N0cmluZyIsInZhbHVlIiwiYnl0ZXMiLCJ1aW50IiwicHJvamVjdENvdW50U3RhdGUiLCJmaW5kIiwicHJvamVjdENvdW50IiwicHJvamVjdHMiLCJpIiwiZ2V0UHJvamVjdFZhbHVlIiwic3VmZml4IiwicG9zc2libGVLZXlzIiwia2V5UGF0dGVybiIsInN0YXRlIiwiam9pbiIsImNyZWF0b3IiLCJhY3RpdmUiLCJwdXNoIiwiaWQiLCJjb2xsZWN0ZWRBbW91bnQiLCJ0aHJlc2hvbGQiLCJ3aXRoZHJhd0Z1bmRzIiwiY2xhaW1SZWZ1bmQiLCJtaW50UmV3YXJkTkZUIiwib3B0SW5Ub0FwcCIsIm1ha2VBcHBsaWNhdGlvbk9wdEluVHhuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/algorand.ts\n"));

/***/ })

});